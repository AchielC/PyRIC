<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>PyRIC by wraith-wireless</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/wraith-wireless/PyRIC">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/wraith-wireless/PyRIC/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/wraith-wireless/PyRIC/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>PyRIC</h1>
          <p>Pythonic iw (and more) for the Wireless Pentester</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/wraith-wireless">wraith-wireless</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="pyric-python-radio-interface-controller" class="anchor" href="#pyric-python-radio-interface-controller" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PyRIC: Python Radio Interface Controller</h1>

<h2>
<a id="linux-wireless-library-for-the-python-wireless-developer-and-pentester" class="anchor" href="#linux-wireless-library-for-the-python-wireless-developer-and-pentester" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Linux wireless library for the Python Wireless Developer and Pentester</h2>

<p><a href="https://github.com/wraith-wireless/PyRIC/blob/master/LICENSE"><img src="https://img.shields.io/pypi/l/PyRIC.svg" alt="License: GPLv3"></a>
<a href="https://pypi.python.org/pypi/PyRIC"><img src="https://img.shields.io/pypi/v/PyRIC.svg" alt="Current version at PyPI"></a>
<a href="https://pypi.python.org/pypi/PyRIC"><img src="https://img.shields.io/pypi/dm/PyRIC.svg" alt="Downloads per month on PyPI"></a>
<img src="https://img.shields.io/pypi/pyversions/PyRIC.svg" alt="Supported Python Versions">
<img src="https://img.shields.io/pypi/status/PyRIC.svg" alt="Software status"></p>

<h2>
<a id="1-description" class="anchor" href="#1-description" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1 DESCRIPTION:</h2>

<p>PyRIC (is a Linux only) library providing wireless developers and pentesters the
ability to identify, enumerate and manipulate their system's wireless cards
programmatically in Python. Pentesting applications and scripts written in Python
have increased dramatically in recent years. However, these tools still rely on
Linux command lines tools to setup and prepare and restore the system for use.
Until now. Why use subprocess.Popen, regular expressions and str.find to interact
with your wireless cards? PyRIC is:</p>

<ol>
<li>Pythonic: no ctypes, SWIG etc. PyRIC redefines C header files as Python and
uses sockets to communicate with the kernel.</li>
<li>Self-sufficient: No third-party files used. PyRIC is completely self-contained.</li>
<li>Fast: (relatively speaking) PyRIC is faster than using command line tools
through subprocess.Popen</li>
<li>Parseless: Get the output you want without parsing output from command line
tools. Never worry about newer iw versions and having to rewrite your parsers.</li>
<li>Easy: If you can use iw, you can use PyRIC.</li>
</ol>

<p>At it's heart, PyRIC is a Python port of (a subset of) iw and by extension, a
Python port of Netlink w.r.t nl80211 functionality. The original goal of PyRIC
was to provide a simple interface to the underlying nl80211 kernel support,
handling the complex operations of Netlink seamlessy while maintaining a minimum
of "code walking" to understand, modify and extend. But, why stop there? Since
it's initial inception, PyRIC has grown to include ioctl support to replicate
features of ifconfig such as getting or setting the mac address and has recently
implemented rkill support to soft block or unblock wireless cards.</p>

<h3>
<a id="a-additions-to-iw" class="anchor" href="#a-additions-to-iw" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>a. Additions to iw</h3>

<p>Several "extensions" have been added to iw:</p>

<ul>
<li>Persistent sockets: pyw provides the caller with functions &amp; ability to pass
their own netlink (or ioctl socket) to pyw functions;</li>
<li>One-time request for the nl80211 family id: pyw stores the family id in a
global variable</li>
<li>Consolidating different "reference" values to wireless NICs in one class
(Cards are tuples t=(dev,phy #,ifindex)</li>
</ul>

<p>These are minimal changes but they can improve the performance of any progams
that needs to access the wireless nic repeatedly as shown in the table below.</p>

<table>
<thead>
<tr>
<th>chset</th>
<th>Total</th>
<th>Avg</th>
<th>Longest</th>
<th>Shortest</th>
</tr>
</thead>
<tbody>
<tr>
<td>Popen(iw)</td>
<td>588.3059</td>
<td>0.0588</td>
<td>0.0682</td>
<td>0.0021</td>
</tr>
<tr>
<td>one-time</td>
<td>560.3559</td>
<td>0.0560</td>
<td>0.0645</td>
<td>0.0003</td>
</tr>
<tr>
<td>persistent</td>
<td>257.8293</td>
<td>0.0257</td>
<td>0.0354</td>
<td>0.0004</td>
</tr>
</tbody>
</table>

<p>The table shows benchmarks for hop time on a Alfa AWUS036NH 10000 times. Note that
there is no implication that PyRIC is faster than iw. Rather, the table shows that
PyRIC is faster than using Popen to execute iw. Using one-time sockets, there is
a difference of 28 seconds over Popen and iw with a small decrease in the average
hoptime. Not a big difference. However, the performance increased dramatically when
persistent netlink sockets are used with the total time and average hop time nearly
halved.</p>

<h3>
<a id="b-current-state" class="anchor" href="#b-current-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>b. Current State</h3>

<p>ATT, PyRIC accomplishes my core needs but it is still a work in progress. It
currently provides the following:</p>

<ul>
<li>enumerate interfaces and wireless interfaces</li>
<li>identify a cards chipset and driver</li>
<li>get/set hardware address</li>
<li>get/set ip4 address, netmask and or broadcast</li>
<li>turn card on/off</li>
<li>get supported standards</li>
<li>get supported commands</li>
<li>get supported modes</li>
<li>get dev info</li>
<li>get phy info</li>
<li>get/set regulatory domain</li>
<li>get/set mode</li>
<li>add/delete interfaces</li>
<li>enumerate ISM and UNII channels</li>
<li>block/unblock rfkill devices</li>
</ul>

<p>It also provides limited help functionality concerning nl80211 commands/attributes
(for those who wish to add additional commands). However, it pulls directly from
the nl80211 header file and may be vague.</p>

<h3>
<a id="c-what-is-pyric" class="anchor" href="#c-what-is-pyric" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>c. What is PyRIC?</h3>

<p>To avoid confusion, PyRIC is the system as a whole, including all header files
and "libraries" that are required to communicate with the kernel. pyw is a
interface to these libraries providing specific funtions.</p>

<p>What it does - defines programmatic access to a subset of iw, ifconfig and rkill.
In short, PyRIC provides Python wireless pentesters the ability to work with
wireless cards directly from Python without having to use command line tools
through Popen.</p>

<h2>
<a id="2-installingusing" class="anchor" href="#2-installingusing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. INSTALLING/USING:</h2>

<h3>
<a id="a-requirements" class="anchor" href="#a-requirements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>a. Requirements</h3>

<p>PyRIC has only two requirements: Linux and Python. There has been very little
testing (on my side) on kernel 4.x and Python 3 but unit testing confirms
functionality on Python 2.7 and kernel 3.13.x.</p>

<h3>
<a id="b-install-from-package-manager" class="anchor" href="#b-install-from-package-manager" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>b. Install from Package Manager</h3>

<p>Obviously, the easiest way to install PyRIC is through PyPI:</p>

<pre><code>sudo pip install PyRIC
</code></pre>

<h3>
<a id="c-install-from-source" class="anchor" href="#c-install-from-source" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>c. Install from Source</h3>

<p>The PyRIC source (tarball) can be downloaded from <a href="https://pypi.python.org/pypi/PyRIC">https://pypi.python.org/pypi/PyRIC</a>
or <a href="http://wraith-wireless.github.io/PyRIC">http://wraith-wireless.github.io/PyRIC</a>. Additionally, the source, as a zip file,
can be downloaded from <a href="https://github.com/wraith-wireless/PyRIC">https://github.com/wraith-wireless/PyRIC</a>. Once downloaded,
extract the files and from the PyRIC directory run:</p>

<pre><code>sudo python setup.py install
</code></pre>

<h3>
<a id="d-test-without-installing" class="anchor" href="#d-test-without-installing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>d. Test without Installing</h3>

<p>If you just want to test PyRIC out, download your choice from above. After extraction,
move the pyric folder (the package directory) to your location of choice and from
there start Python and import pyw. It is very important that you do not try and
run it from PyRIC which is the distribution directory. This will break the imports
pyw uses.</p>

<p>You will only be able to test PyRIC from the pyric directory but, if you want to,
you can add it to your Python path and run it from any program or any location.
To do so, assume you untared PyRIC to /home/bob/PyRIC. Create a text file named
pyric.pth with one line</p>

<pre><code>/home/bob/PyRIC
</code></pre>

<p>and save this file to /usr/lib/python2.7/dist-packages (or /usr/lib/python3/dist-packages
if you want to try it in Python 3).</p>

<h3>
<a id="e-stability-vs-latest" class="anchor" href="#e-stability-vs-latest" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>e. Stability vs Latest</h3>

<p>Keep in mind that the most stable version and easist installallation but oldest
release is on PyPI (installed through pip). The source on <a href="http://wraith-wireless.github.io/PyRIC">http://wraith-wireless.github.io/PyRIC</a> tends to be
newer but may have some bugs. The most recent source but hardest to install is on
<a href="https://github.com/wraith-wireless/pyric/releases/">https://github.com/wraith-wireless/pyric/releases/</a> It is not guaranteed to be stable
(as I tend to commit changes periodically while working on the code) and may in
fact not run at all.</p>

<h2>
<a id="3-using" class="anchor" href="#3-using" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. USING</h2>

<p>Once installed, see examples/pentest.py which covers most pyw functions or read
throuhg PyRIC.pdf. However, for those impatient types:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pyric          <span class="pl-c"># pyric error and EUNDEF error code</span>
<span class="pl-k">from</span> pyric <span class="pl-k">import</span> pyw  iw functionality</pre></div>

<p>will import the basic requirements and is assumed for the examples below. It is also assumed
that the system is in the US and has three devices lo, eth0 and wlan0 (only wlan0 of course
being wireless). Keep in mind that these examples use one-time sockets.</p>

<h3>
<a id="a-wireless-core-functionality" class="anchor" href="#a-wireless-core-functionality" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>a. Wireless Core Functionality</h3>

<p>These functions do not work with a specific device rather with the system.</p>

<div class="highlight highlight-source-python"><pre>
pyw.interfaces() <span class="pl-c"># get all system interfaces</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> [<span class="pl-s"><span class="pl-pds">'</span>lo<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>]

pyw.isinterface(<span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>) <span class="pl-c"># deterimine if eth0 is an interface</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">True</span>

pyw.isinterface(<span class="pl-s"><span class="pl-pds">'</span>bob0<span class="pl-pds">'</span></span>)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">False</span>

pyw.winterfaces() <span class="pl-c"># get all system wireless interfaces</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> [<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>]

pyw.isinterface(<span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>) <span class="pl-c"># check eth0 for wireless</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">False</span>

pyw.iswinterface(<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">True</span>

pyw.regget() <span class="pl-c"># get the regulatory domain</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>US<span class="pl-pds">'</span></span>

pyw.regset(<span class="pl-s"><span class="pl-pds">'</span>BO<span class="pl-pds">'</span></span>) <span class="pl-c"># set the regulatory domain</span>

pyw.regget()
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>BO<span class="pl-pds">'</span></span></pre></div>

<h3>
<a id="b-interface-specific" class="anchor" href="#b-interface-specific" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>b. Interface Specific</h3>

<p>Recall that PyRIC utilizes a Card object - this removes the necessity of having  to
remember what to pass each function i.e. whether it is a device name, physical index
or ifindex.</p>

<div class="highlight highlight-source-python"><pre>w0 <span class="pl-k">=</span> pyw.getcard(<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>) <span class="pl-c"># get a card for wlan0</span>

w0
<span class="pl-k">=</span><span class="pl-k">&gt;</span> Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>

<p>You can also use pyw.devinfo to get a Card object and pyw.devadd will return a card
object for the newly created virtual interface. The card, w0, will be used throughout
the remainder of the examples.</p>

<h4>
<a id="i-setting-mac-and-ip-addresses" class="anchor" href="#i-setting-mac-and-ip-addresses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>i. Setting Mac and IP Addresses</h4>

<div class="highlight highlight-source-python"><pre>mac <span class="pl-k">=</span> pyw.macget(w0) <span class="pl-c"># get the hw addr</span>

mac
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>a0:b1:c2:d3:e4:f5<span class="pl-pds">'</span></span>

pyw.down(w0) <span class="pl-c"># turn the card off to set the mac</span>

pyw.macset(w0,<span class="pl-s"><span class="pl-pds">'</span>00:1F:32:00:01:00<span class="pl-pds">'</span></span>) <span class="pl-c"># lets be a nintendo device</span>

pyw.up(w0) <span class="pl-c"># bring wlan0 back up</span>

pyw.macget(w0) <span class="pl-c"># see if it worked</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>00:1F:32:00:01:00<span class="pl-pds">'</span></span>

pyw.inetget(w0) <span class="pl-c"># not associated, inet won't return an address</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> (<span class="pl-c1">None</span>, <span class="pl-c1">None</span>, <span class="pl-c1">None</span>)

pyw.inetset(w0,<span class="pl-s"><span class="pl-pds">'</span>192.168.3.23<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>255.255.255.192<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>192.168.3.63<span class="pl-pds">'</span></span>)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">True</span>

pyw.inetget(w0)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> (<span class="pl-s"><span class="pl-pds">'</span>192.168.3.23<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>255.255.255.192<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>192.168.3.255<span class="pl-pds">'</span></span>)</pre></div>

<p>It is important to note that (like ifconfig), erroneous values can be set
when setting the inet addresses: for example you can set the ip address on
192.168.3.* network with a broadcast address of 10.255.255.255.</p>

<h4>
<a id="ii-getting-info-on-your-card" class="anchor" href="#ii-getting-info-on-your-card" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ii. Getting Info On Your Card</h4>

<div class="highlight highlight-source-python"><pre>pyw.devinfo(w0)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> {<span class="pl-s"><span class="pl-pds">'</span>wdev<span class="pl-pds">'</span></span>: <span class="pl-c1">4294967297</span>, <span class="pl-s"><span class="pl-pds">'</span>RF<span class="pl-pds">'</span></span>: <span class="pl-c1">None</span>, <span class="pl-s"><span class="pl-pds">'</span>CF<span class="pl-pds">'</span></span>: <span class="pl-c1">None</span>, <span class="pl-s"><span class="pl-pds">'</span>mac<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>00:c0:ca:59:af:a6<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-pds">'</span>mode<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>CHW<span class="pl-pds">'</span></span>: <span class="pl-c1">None</span>, <span class="pl-s"><span class="pl-pds">'</span>card<span class="pl-pds">'</span></span>: Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">dev</span><span class="pl-k">=</span>alfa0,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">4</span>)}

pyw.txget(w0)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">20</span>

pyw.modeget(w0)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>

pyw.devstds(w0)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> [<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>n<span class="pl-pds">'</span></span>]

pyw.devmodes(w0)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> [<span class="pl-s"><span class="pl-pds">'</span>ibss<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>AP<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>AP VLAN<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>wds<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>mesh<span class="pl-pds">'</span></span>]

pyw.devcmds(w0)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> [<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_interface<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_interface<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_key<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>start_ap<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_station<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_mpath<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_mesh_config<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_bss<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>authenticate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>associate<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>deauthenticate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>disassociate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>join_ibss<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>join_mesh<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_tx_bitrate_mask<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>frame<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>frame_wait_cancel<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_wiphy_netns<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_channel<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_wds_peer<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>probe_client<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_noack_map<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>register_beacons<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>start_p2p_device<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_mcast_rate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>connect<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>disconnect<span class="pl-pds">'</span></span>]

pinfo <span class="pl-k">=</span> pyw.phyinfo(w0)

pinfo[<span class="pl-s"><span class="pl-pds">'</span>scan_ssids<span class="pl-pds">'</span></span>]
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>

pinfo[<span class="pl-s"><span class="pl-pds">'</span>retry_short<span class="pl-pds">'</span></span>]
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">7</span>

pinfo[<span class="pl-s"><span class="pl-pds">'</span>retry_long<span class="pl-pds">'</span></span>]
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>

pinfo[<span class="pl-s"><span class="pl-pds">'</span>frag_thresh<span class="pl-pds">'</span></span>]
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">4294967295</span>

pinfo[<span class="pl-s"><span class="pl-pds">'</span>rts_thresh<span class="pl-pds">'</span></span>]
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">4294967295</span>

pinfo[<span class="pl-s"><span class="pl-pds">'</span>cov_class<span class="pl-pds">'</span></span>]
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">0</span>

pinfo[<span class="pl-s"><span class="pl-pds">'</span>freqs<span class="pl-pds">'</span></span>]
<span class="pl-k">=</span><span class="pl-k">&gt;</span>[<span class="pl-c1">2412</span>, <span class="pl-c1">2417</span>, <span class="pl-c1">2422</span>, <span class="pl-c1">2427</span>, <span class="pl-c1">2432</span>, <span class="pl-c1">2437</span>, <span class="pl-c1">2442</span>, <span class="pl-c1">2447</span>, <span class="pl-c1">2452</span>, <span class="pl-c1">2457</span>, <span class="pl-c1">2462</span>, <span class="pl-c1">2467</span>, <span class="pl-c1">2472</span>,
<span class="pl-c1">2484</span>]</pre></div>

<p>Read the user guide, or type dir(pyw) in your console to get a full listing
of pyw functions.</p>

<p>c. Miscelleaneous Utilities
Several additional tools are located in the utils directory. Two of these are:</p>

<ul>
<li>channels.py: defines ISM and UNII band channels/frequencies and provides
functions to convert between channel and frequency and vice-versa</li>
<li>ouifetch.py: retrieves and parses oui.txt from the IEEE website and stores
the oui data in a file that can be read by hardware.py functions
The others will be demonstrated in the following functions</li>
</ul>

<p>i. hardware.py
Driver, chipset and mac address related functions can be found here:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pyric.utils.hardware <span class="pl-k">as</span> hw

ouis <span class="pl-k">=</span> hw.parseoui() <span class="pl-c"># load the oui dict</span>
<span class="pl-c1">len</span>(ouis)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">22128</span>

mac <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>a0:88:b4:9e:68:58<span class="pl-pds">'</span></span>
dev <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>

hw.oui(mac)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>a0:88:b4<span class="pl-pds">'</span></span>

hw.ulm(mac)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>9e:68:58<span class="pl-pds">'</span></span>

hw.manufacturer(ouis,mac)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Intel Corporate<span class="pl-pds">'</span></span>

hw.randhw(ouis) <span class="pl-c"># generate a random mac address</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span><span class="pl-s"><span class="pl-pds">'</span>00:03:f0:5a:a1:fc<span class="pl-pds">'</span></span>

hw.manufacturer(ouis,<span class="pl-s"><span class="pl-pds">'</span>00:03:f0:5a:a1:fc<span class="pl-pds">'</span></span>)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Redfern Broadband Networks<span class="pl-pds">'</span></span>

hw.ifcard(<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>) <span class="pl-c"># get driver &amp; chipset</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> (<span class="pl-s"><span class="pl-pds">'</span>iwlwifi<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Intel 4965/5xxx/6xxx/1xxx<span class="pl-pds">'</span></span>)</pre></div>

<p>ii. rfkill.py
Sometimes, your card has a soft block (or hard block) on it and it is not
recognized by command line tools or pyw. Use rkill to list, turn on or turn
off soft blocks.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> pyric.utils <span class="pl-k">import</span> rfkill

rfkill.rfkill_list() <span class="pl-c"># list rfkill devices</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> {<span class="pl-s"><span class="pl-pds">'</span>tpacpi_bluetooth_sw<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>bluetooth<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">1</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy3<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">5</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy0<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>}}

idx <span class="pl-k">=</span> rfkill.getidx(<span class="pl-c1">3</span>)
idx
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">5</span>

rfkill.getname(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> phy3

rfkill.gettype(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>

rfkill.soft_blocked(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">False</span>

rfkill.hard_blocked(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">False</span>

rfkill.rfkill_block(idx)

rfkill.list()
<span class="pl-k">=</span><span class="pl-k">&gt;</span> {<span class="pl-s"><span class="pl-pds">'</span>tpacpi_bluetooth_sw<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>bluetooth<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">1</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy3<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">5</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy0<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>}}

rfkill.rfkill_unblock(idx)

rfkill.rfkill_list()
<span class="pl-k">=</span><span class="pl-k">&gt;</span> {<span class="pl-s"><span class="pl-pds">'</span>tpacpi_bluetooth_sw<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>bluetooth<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">1</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy3<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">5</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy0<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>}}</pre></div>

<p>Note that rfkill_list lists all 'wireless' devices: wlan, bluetooth, wimax, wwan,
gps, fm and nfc. Another important thing to note is that the rfkill index is not
the same as the interface index.</p>

<h4>
<a id="iii-virtual-interfaces" class="anchor" href="#iii-virtual-interfaces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>iii. Virtual Interfaces</h4>

<p>In my experience, virtual interfaces are primarily used to recon, attack or some
other tomfoolery but can also be used to analyze your wireless network. In either
case, it is generally advised to create a virtual monitor interface and delete
all others (on the same phy) - this makes sure that some external process like
NetworkManager does not interfere with your shenanigans. In the below example,
in addition to creating an interface in monitor mode, we find all interfaces
on the same physical index and delete them. You may not need to do this.</p>

<p>NOTE: When creating a device in monitor mode, you can also set flags (see
NL80211_MNTR_FLAGS in nl80211_h), although some cards (usually atheros) do not
always obey these requests.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span> <span class="pl-k">in</span> pyw.devmodes(w0) <span class="pl-c"># make sure we can set wlan0 to monitor</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">True</span>

m0 <span class="pl-k">=</span> pyw.devadd(w0,<span class="pl-s"><span class="pl-pds">'</span>mon0<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>) <span class="pl-c"># create mon0 in monitor mode</span>

<span class="pl-k">for</span> iface <span class="pl-k">in</span> pyw.ifaces(w0): <span class="pl-c"># delete all interfaces</span>
    pyw.devdel(iface[<span class="pl-c1">0</span>])     <span class="pl-c"># on the this phy</span>

pyw.up(m0) <span class="pl-c"># bring the new card up to use</span>

pyw.chset(m0,<span class="pl-c1">6</span>,<span class="pl-c1">None</span>) <span class="pl-c"># and set the card to channel 6</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">True</span>

m0
<span class="pl-k">=</span><span class="pl-k">&gt;</span> Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>mon0<span class="pl-pds">'</span></span>,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>

<p>Of course, once you are done, you will probably want to restore your original set
up.</p>

<div class="highlight highlight-source-python"><pre>w0 <span class="pl-k">=</span> pyw.devadd(m0,<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>) <span class="pl-c"># restore wlan0 in managed mode</span>

pyw.devdel(m0) <span class="pl-c"># delete the monitor interface</span>

pyw.setmac(w0,mac) <span class="pl-c"># restore the original mac address</span>

pyw.up(w0) <span class="pl-c"># and bring the card up</span>

w0
<span class="pl-k">=</span><span class="pl-k">&gt;</span> Card(phy0,<span class="pl-v">dev</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">4</span>)
</pre></div>

<h2>
<a id="4-extending" class="anchor" href="#4-extending" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4. EXTENDING:</h2>

<p>Extending PyRIC is fun and easy too, see the user guide PyRIC.pdf.</p>

<h2>
<a id="5-architectureheirarchy" class="anchor" href="#5-architectureheirarchy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5. ARCHITECTURE/HEIRARCHY:</h2>

<p>Brief Overview of the project file structure. Directories and/or files annotated
with (-) are not included in pip installs or PyPI downloads</p>

<ul>
<li>PyRIC                   root Distribution directory

<ul>
<li>__init__.py       initialize distrubution PyRIC module</li>
<li>examples              example folder

<ul>
<li>pentest.py          create wireless pentest environment example</li>
<li>device_details.py   display device information</li>
</ul>
</li>
<li>tests (-)             test folder

<ul>
<li>pyw.unittest.py     unit test for pyw functions</li>
</ul>
</li>
<li>docs                  User Guide resources

<ul>
<li>nlsend.png (-)      image for user guide</li>
<li>nlsock.png (-)      image for user guide</li>
<li>PyRIC.tex (-)       User tex file</li>
<li>PyRIC.bib (-)       User Guide bibliography</li>
<li>PyRIC.pdf           User Guide</li>
</ul>
</li>
<li>setup.py              install file</li>
<li>setup.cfg             used by setup.py</li>
<li>MANIFEST.in           used by setup.py</li>
<li>README.md             this file</li>
<li>LICENSE               GPLv3 License</li>
<li>TODO                  todos for PyRIC</li>
<li>pyric                 package directory

<ul>
<li>__init__.py     initialize pyric module</li>
<li>pyw.py              wireless nic functionality</li>
<li>utils               utility directory</li>
<li>__init__.py    initialize utils module</li>
<li>channels.py        802.11 ISM/UNII freqs. &amp; channels</li>
<li>hardware.py        device, chipset and mac address utility functions</li>
<li>rfkill.py          rfkill functions</li>
<li>ouifetch.py        retrieve and store oui dict from IEEE</li>
<li>data               data folder for ouis</li>
<li>oui.txt           oui file fetched from IEEE</li>
<li>net                 linux header ports

<ul>
<li>__init__.py   initialize net subpackage</li>
<li>if_h.py           inet/ifreq definition</li>
<li>sockios_h.py      socket-level I/O control calls</li>
<li>genetlink_h.py    port of genetlink.h</li>
<li>netlink_h.py      port of netlink.h</li>
<li>policy.py         defines attribute datatypes</li>
<li>wireless          wireless subpackage

<ul>
<li>__init__.py initialize wireless subpackage</li>
<li>nl80211_h.py    nl80211 constants</li>
<li>nl80211_c.py    nl80211 attribute policies</li>
<li>rfkill_h.py     rfkill header file</li>
</ul>
</li>
</ul>
</li>
<li>lib                 library subpackages

<ul>
<li>__init__.py   initialize lib subpackage</li>
<li>libnl.py          netlink helper functions</li>
<li>libio.py          sockios helper functions</li>
</ul>
</li>
<li>nlhelp              netlinke documentation/help

<ul>
<li>nsearch.py        nl80211 search</li>
<li>commands.help     nl80211 commands help data</li>
<li>attributes.help   nl80211 attributes help data</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
