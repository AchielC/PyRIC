<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>PyRIC by wraith-wireless</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>PyRIC</h1>
        <p>Pythonic iw (and more) for the Wireless Pentester</p>

        <p class="view"><a href="https://github.com/wraith-wireless/PyRIC">View the Project on GitHub <small>wraith-wireless/PyRIC</small></a></p>


        <ul>
          <li><a href="https://github.com/wraith-wireless/PyRIC/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/wraith-wireless/PyRIC/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/wraith-wireless/PyRIC">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="pyric-015-python-radio-interface-controller" class="anchor" href="#pyric-015-python-radio-interface-controller" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PyRIC 0.1.5: Python Radio Interface Controller</h1>

<h2>
<a id="linux-wireless-library-for-the-python-wireless-developer-and-pentester" class="anchor" href="#linux-wireless-library-for-the-python-wireless-developer-and-pentester" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Linux wireless library for the Python Wireless Developer and Pentester</h2>

<p><img src="docs/logo.png?raw=true" alt=""></p>

<p><a href="https://github.com/wraith-wireless/PyRIC/blob/master/LICENSE"><img src="https://img.shields.io/pypi/l/PyRIC.svg" alt="License: GPLv3"></a>
<a href="https://pypi.python.org/pypi/PyRIC"><img src="https://img.shields.io/pypi/v/PyRIC.svg" alt="PyPI Version"></a>
<a href="https://pypi.python.org/pypi/PyRIC"><img src="https://img.shields.io/pypi/dm/PyRIC.svg" alt="Downloads per month on PyPI"></a>
<img src="https://img.shields.io/pypi/pyversions/PyRIC.svg" alt="Supported Python Versions">
<img src="https://img.shields.io/pypi/status/PyRIC.svg" alt="Software status">
<a href="http://pyric.readthedocs.io/en/latest/?badge=latest"><img src="https://readthedocs.org/projects/pyric/badge/?version=latest" alt="Documentation Status"></a></p>

<h2>
<a id="1-description" class="anchor" href="#1-description" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1 DESCRIPTION:</h2>

<p>PyRIC (is a Linux only) library providing wireless developers and pentesters the
ability to identify, enumerate and manipulate their system's wireless cards
programmatically in Python. Pentesting applications and scripts written in Python
have increased dramatically in recent years. However, these tools still rely on
Linux command lines tools to setup and prepare and restore the system for use.
Until now. Why use subprocess.Popen, regular expressions and str.find to interact
with your wireless cards? PyRIC is:</p>

<ol>
<li>Pythonic: no ctypes, SWIG etc. PyRIC redefines C header files as Python and
uses sockets to communicate with the kernel.</li>
<li>Self-sufficient: No third-party files used. PyRIC is completely self-contained.</li>
<li>Fast: (relatively speaking) PyRIC is faster than using command line tools
through subprocess.Popen</li>
<li>Parseless: Get the output you want without parsing output from command line
tools. Never worry about newer iw versions and having to rewrite your parsers.</li>
<li>Easy: If you can use iw, you can use PyRIC.</li>
</ol>

<p>At it's heart, PyRIC is a Python port of (a subset of) iw and by extension, a
Python port of Netlink w.r.t nl80211 functionality. The original goal of PyRIC
was to provide a simple interface to the underlying nl80211 kernel support,
handling the complex operations of Netlink seamlessy while maintaining a minimum
of "code walking" to understand, modify and extend. But, why stop there? Since
it's initial inception, PyRIC has grown. PyRIC puts iw, ifconfig, rfkill,
udevadm, airmon-ng and macchanger in your hands (or your program).</p>

<h3>
<a id="a-additions-to-iw" class="anchor" href="#a-additions-to-iw" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>a. Additions to iw</h3>

<p>Several "extensions" have been added to iw:</p>

<ul>
<li>Persistent sockets: pyw provides the caller with functions &amp; ability to pass
their own netlink (or ioctl socket) to pyw functions;</li>
<li>One-time request for the nl80211 family id: pyw stores the family id in a
global variable</li>
<li>Consolidate different "reference" values to wireless NICs in one class
(Cards are tuples t=(dev,phy #,ifindex)</li>
</ul>

<p>These are minimal changes but they can improve the performance of any progams
that needs to access the wireless nic repeatedly as shown in the table below.</p>

<table>
<thead>
<tr>
<th>chset</th>
<th>Total</th>
<th>Avg</th>
<th>Longest</th>
<th>Shortest</th>
</tr>
</thead>
<tbody>
<tr>
<td>Popen(iw)</td>
<td>588.3059</td>
<td>0.0588</td>
<td>0.0682</td>
<td>0.0021</td>
</tr>
<tr>
<td>one-time</td>
<td>560.3559</td>
<td>0.0560</td>
<td>0.0645</td>
<td>0.0003</td>
</tr>
<tr>
<td>persistent</td>
<td>257.8293</td>
<td>0.0257</td>
<td>0.0354</td>
<td>0.0004</td>
</tr>
</tbody>
</table>

<p>The table shows benchmarks for hop time on a Alfa AWUS036NH 10000 times. Note that
there is no implication that PyRIC is faster than iw. Rather, the table shows that
PyRIC is faster than using Popen to execute iw. Using one-time sockets, there is
a difference of 28 seconds over Popen and iw with a small decrease in the average
hoptime. Not a big difference. However, the performance increased dramatically when
persistent netlink sockets are used with the total time and average hop time nearly
halved.</p>

<h3>
<a id="b-current-state" class="anchor" href="#b-current-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>b. Current State</h3>

<p>PyRIC is in the process of porting compatibility to Python 3. At present, it will
work on Python 2.7 and Python 3.5. It will also work on Python 3.0 except you
will have to manually enter your devices in the examples (as argparse is not
supported) and you will not be able to run pyw.unittest.py.</p>

<p>ATT, PyRIC provides the following:</p>

<ul>
<li>enumerate interfaces and wireless interfaces</li>
<li>identify a cards driver, chipset and manufacturer</li>
<li>get/set hardware address</li>
<li>get/set ip4 address, netmask and or broadcast</li>
<li>turn card on/off</li>
<li>get supported standards, commands or modes</li>
<li>get if info</li>
<li>get dev info</li>
<li>get phy info</li>
<li>get link info</li>
<li>get STA (connected AP) info</li>
<li>get/set regulatory domain</li>
<li>get/set mode</li>
<li>get/set coverage class, RTS threshold, Fragmentation threshold &amp; retry limits</li>
<li>add/delete interfaces</li>
<li>determine if a card is connected</li>
<li>get link info for a connected card</li>
<li>enumerate ISM and UNII channels</li>
<li>block/unblock rfkill devices</li>
</ul>

<p>In utils, several helpers can be found that can be used to:</p>

<ul>
<li>enumerate channels and frequencies and convert between the two</li>
<li>manipulate mac addresses and generate random ones</li>
<li>fetch and parse the IEEE oui text file</li>
<li>further rfkill operations to include listing all rfkill devices</li>
</ul>

<p>For a full listing of every function offered by pyw and helpers see the user
guide PyRIC.pdf.</p>

<p>PyRIC also provides limited help functionality concerning nl80211 commands/attributes
for those who wish to add additional commands. However, it pulls directly from
the comments nl80211 header file and may be vague.</p>

<h3>
<a id="c-what-is-pyric" class="anchor" href="#c-what-is-pyric" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>c. What is PyRIC?</h3>

<p>To avoid confusion, PyRIC is the system as a whole, including all header files
and "libraries" that are required to communicate with the kernel. pyw is a
interface to these libraries providing specific funtions.</p>

<p>What it does - defines programmatic access to a subset of iw, ifconfig and rkill.
In short, PyRIC provides Python wireless pentesters the ability to work with
wireless cards directly from Python without having to use command line tools
through Popen.</p>

<h2>
<a id="2-installingusing" class="anchor" href="#2-installingusing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. INSTALLING/USING:</h2>

<h3>
<a id="a-requirements" class="anchor" href="#a-requirements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>a. Requirements</h3>

<p>PyRIC has only two requirements: Linux and Python. There has been very little
testing (on my side) on kernel 4.x and Python 3 but unit testing confirms
functionality on Python 2.7 and kernel 3.13.x.</p>

<h3>
<a id="b-install-from-package-manager" class="anchor" href="#b-install-from-package-manager" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>b. Install from Package Manager</h3>

<p>Obviously, the easiest way to install PyRIC is through PyPI:</p>

<pre><code>sudo pip install PyRIC
</code></pre>

<h3>
<a id="c-install-from-source" class="anchor" href="#c-install-from-source" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>c. Install from Source</h3>

<p>The PyRIC source (tarball) can be downloaded from <a href="https://pypi.python.org/pypi/PyRIC">https://pypi.python.org/pypi/PyRIC</a>
or <a href="http://wraith-wireless.github.io/PyRIC">http://wraith-wireless.github.io/PyRIC</a>. Additionally, the source, as a zip file,
can be downloaded from <a href="https://github.com/wraith-wireless/PyRIC">https://github.com/wraith-wireless/PyRIC</a>. Once downloaded,
extract the files and from the PyRIC directory run:</p>

<pre><code>sudo python setup.py install
</code></pre>

<h3>
<a id="d-test-without-installing" class="anchor" href="#d-test-without-installing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>d. Test without Installing</h3>

<p>If you just want to test PyRIC out, download your choice from above. After extraction,
move the pyric folder (the package directory) to your location of choice and from
there start Python and import pyw. It is very important that you do not try and
run it from PyRIC which is the distribution directory. This will break the imports
pyw uses.</p>

<p>You will only be able to test PyRIC from the pyric directory but, if you want to,
you can add it to your Python path and run it from any program or any location.
To do so, assume you untared PyRIC to /home/bob/PyRIC. Create a text file named
pyric.pth with one line</p>

<pre><code>/home/bob/PyRIC
</code></pre>

<p>and save this file to /usr/lib/python2.7/dist-packages (or /usr/lib/python3/dist-packages
if you want to try it in Python 3).</p>

<h3>
<a id="e-stability-vs-latest" class="anchor" href="#e-stability-vs-latest" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>e. Stability vs Latest</h3>

<p>Keep in mind that the most stable version and easist installallation but oldest
release is on PyPI (installed through pip). The source on <a href="http://wraith-wireless.github.io/PyRIC">http://wraith-wireless.github.io/PyRIC</a> tends to be
newer but may have some bugs. The most recent source but hardest to install is on
<a href="https://github.com/wraith-wireless/pyric/releases/">https://github.com/wraith-wireless/pyric/releases/</a> It is not guaranteed to be stable
(as I tend to commit changes periodically while working on the code) and may in
fact not run at all.</p>

<h2>
<a id="3-using" class="anchor" href="#3-using" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. USING</h2>

<p>To use PyRIC, see the examples folder or read throuhg PyRIC.pdf. However, for
those impatient types:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pyric             <span class="pl-c"># pyric errors</span>
<span class="pl-k">import</span> pyric.pyw <span class="pl-k">as</span> pyw  <span class="pl-c"># iw functionality</span></pre></div>

<p>will import the basic requirements and unless otherwise stated is assumed for the
examples below. It is also assumed that the system is in the US and has three
devices lo, eth0 and wlan0 (only wlan0 of course being wireless). Keep in mind
that these examples use one-time sockets.</p>

<p>Although not all functions require root, we assume that the below have been
executed with root permissions.</p>

<p>Before proceeding with the examples, let's talk about pyric error handling. The
pyric module imports the errorcodes found in the errno module as its own. The 
pyric error subclasses EnvironmentError and all pyric errors are tuples of the 
form t = (error code,error message).</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">try</span>:
<span class="pl-c1">...</span>     <span class="pl-c">#some pyric code</span>
<span class="pl-c1">...</span> <span class="pl-k">except</span> pyric.error <span class="pl-k">as</span> e:
<span class="pl-c1">...</span>     <span class="pl-c">#handle the error</span></pre></div>

<p>Work is ongoing to help clarify some of the error messages returned by default
by os.strerror for example. </p>

<p>Read the user guide, or type dir(pyw) in your console to get a full listing
of all pyw functions.</p>

<h3>
<a id="a-systemwireless-core-functionality" class="anchor" href="#a-systemwireless-core-functionality" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>a. System/Wireless Core Functionality</h3>

<p>These functions do not work with a specific device rather with the system.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.interfaces() <span class="pl-c"># get all system interfaces</span>
[<span class="pl-s"><span class="pl-pds">'</span>lo<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isinterface(<span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>) <span class="pl-c"># deterimine if eth0 is an interface</span>
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isinterface(<span class="pl-s"><span class="pl-pds">'</span>bob0<span class="pl-pds">'</span></span>)
<span class="pl-c1">False</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.winterfaces() <span class="pl-c"># get all system wireless interfaces</span>
[<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isinterface(<span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>) <span class="pl-c"># check eth0 for wireless</span>
<span class="pl-c1">False</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.iswinterface(<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>)
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.phylist() <span class="pl-c"># list all current phys (Note device ASW phy1)</span>
[(<span class="pl-c1">1</span>,<span class="pl-s"><span class="pl-pds">'</span>phy1), (0, <span class="pl-pds">'</span></span>phy0<span class="pl-s"><span class="pl-pds">'</span>)]<span class="pl-ii"></span></span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.regget() <span class="pl-c"># get the regulatory domain</span>
<span class="pl-s"><span class="pl-pds">'</span>US<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.regset(<span class="pl-s"><span class="pl-pds">'</span>BO<span class="pl-pds">'</span></span>) <span class="pl-c"># set the regulatory domain</span>
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.regget()
<span class="pl-s"><span class="pl-pds">'</span>BO<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<h3>
<a id="b-interface-specific" class="anchor" href="#b-interface-specific" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>b. Interface Specific</h3>

<p>Recall that PyRIC utilizes a Card object - this removes the necessity of having
to remember what to pass each function i.e. whether you have to pass a device name,
physical index or ifindex. Unless otherwise stated, we will be using the card
w0 instantiated as:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> w0 <span class="pl-k">=</span> pyw.getcard(<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>) <span class="pl-c"># get a card for wlan0</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> w0
Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>

<p>There are other methods to get a Card object: </p>

<ul>
<li>pyw.devinfo, in addition to information, will return a Card object, </li>
<li>pyw.devadd and pyw.phyadd return a card object for the newly created virtual 
interface, and</li>
<li>pyw.ifaces returns a lists of Cards for every interface sharing the same phy.</li>
</ul>

<p>It is also important to note while most functions require a Card object, some
do not and some will take a Card or a specific identifier. Read the user
guide or code for additional information.</p>

<p>Before continuing you may find that a Card can become invalid. For example, I
have an older system where the USB tends to fall out. You can confirm that your
card is still valid:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.validcard(w0)
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<h4>
<a id="i-why-is-my-card-not-working" class="anchor" href="#i-why-is-my-card-not-working" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>i. Why is my Card not Working?</h4>

<p>Sometimes you may need to turn your Card on, or possibly unblock it.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isup(w0)
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.down(w0)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isup(w0)
<span class="pl-c1">False</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.up(w0)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isblocked(w0) <span class="pl-c"># returns tup;e (Soft Block, Hard Block)</span>
(<span class="pl-c1">True</span>,<span class="pl-c1">False</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.unblock(w0) <span class="pl-c"># turn off the softblock</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isblocked(w0)
(<span class="pl-c1">False</span>,<span class="pl-c1">False</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<h4>
<a id="ii-working-with-mac-and-ip-addresses" class="anchor" href="#ii-working-with-mac-and-ip-addresses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ii. Working with Mac and IP Addresses</h4>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> mac <span class="pl-k">=</span> pyw.macget(w0) <span class="pl-c"># get the hw addr</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> mac
<span class="pl-s"><span class="pl-pds">'</span>a0:b1:c2:d3:e4:f5<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.down(w0): <span class="pl-c"># turn the card off to set the mac</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.macset(w0,<span class="pl-s"><span class="pl-pds">'</span>00:1F:32:00:01:00<span class="pl-pds">'</span></span>) <span class="pl-c"># lets be a nintendo device</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.up(w0) <span class="pl-c"># bring wlan0 back up</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.macget(w0) <span class="pl-c"># see if it worked</span>
<span class="pl-s"><span class="pl-pds">'</span>00:1F:32:00:01:00<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.inetget(w0) <span class="pl-c"># not associated, inet won't return an address</span>
(<span class="pl-c1">None</span>, <span class="pl-c1">None</span>, <span class="pl-c1">None</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># <span class="pl-k">NOTE</span>: to set the inet, bcast or netmask, the card does not have to be down</span>
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.inetset(w0,<span class="pl-s"><span class="pl-pds">'</span>192.168.3.23<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>255.255.255.192<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>192.168.3.63<span class="pl-pds">'</span></span>)
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.inetget(w0)
(<span class="pl-s"><span class="pl-pds">'</span>192.168.3.23<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>255.255.255.192<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>192.168.3.255<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># You can also use ip4set, netmaskset and broadcastset</span></pre></div>

<p>It is important to note that (like ifconfig), erroneous values can be set
when setting the inet addresses: for example you can set the ip address on
192.168.3.* network with a broadcast address of 10.255.255.255.</p>

<h4>
<a id="iii-wlan-radio-properties" class="anchor" href="#iii-wlan-radio-properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>iii. WLAN Radio Properties</h4>

<p>You may want to set power management or other radio properties when pentesting.
Particulary, if you are configuring a rogue AP.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.pwrsaveget(w0)
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.pwrsaveset(w0, <span class="pl-c1">False</span>) <span class="pl-c"># turn off powermanagement</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.pwrsaveget(w0)
<span class="pl-c1">False</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.covclassset(w0, <span class="pl-c1">1</span>) <span class="pl-c"># set the coverage class</span>
pyric.error: [Errno <span class="pl-c1">95</span>] Operation <span class="pl-k">not</span> supported
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># My internal intel card does not support setting the coverage class</span>
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.retryshortset(w0, <span class="pl-c1">5</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.retrylongset(w0, <span class="pl-c1">5</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># We'll check these values out shortly</span>
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.rtsthreshset(w0, <span class="pl-c1">1024</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.fragthreshset(w0, <span class="pl-c1">8000</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<p>For a brief description of coverage class and retry limits,
see <a href="http://www.computerhope.com/unix/iwconfig.htm">http://www.computerhope.com/unix/iwconfig.htm</a>. For a description of the RTS
and Fragmentation thresholds see <a href="http://resources.infosecinstitute.com/rts-threshold-configuration-improved-wireless-network-performance/">http://resources.infosecinstitute.com/rts-threshold-configuration-improved-wireless-network-performance/</a>.
The IEEE 802.11-2012 also covers these. </p>

<h4>
<a id="iv-getting-info-on-your-card" class="anchor" href="#iv-getting-info-on-your-card" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>iv. Getting Info On Your Card</h4>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> iinfo <span class="pl-k">=</span> pyw.ifinfo(w0)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> iinfo: <span class="pl-c1">print</span> i, iinfo[i]
<span class="pl-c1">...</span> 
mask <span class="pl-c1">255.255</span>.255.192
driver iwlwifi
hwaddr a0:<span class="pl-c1">88</span>:b4:<span class="pl-ii">9e</span>:<span class="pl-c1">68</span>:<span class="pl-c1">58</span>
chipset Intel <span class="pl-c1">4965</span><span class="pl-k">/</span><span class="pl-ii">5xxx</span><span class="pl-k">/</span><span class="pl-ii">6xxx</span><span class="pl-k">/</span><span class="pl-ii">1xxx</span>
bcast <span class="pl-c1">192.168</span>.3.63
inet <span class="pl-c1">192.168</span>.3.7
manufacturer Intel Corporate
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> dinfo <span class="pl-k">=</span> pyw.devinfo(w0)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> d <span class="pl-k">in</span> dinfo: <span class="pl-c1">print</span> d, dinfo[d]
<span class="pl-c1">...</span>
wdev <span class="pl-c1">1</span>
<span class="pl-c1">RF</span> <span class="pl-c1">None</span>
<span class="pl-c1">CF</span> <span class="pl-c1">None</span>
mac <span class="pl-c1">00</span>:<span class="pl-ii">1F</span>:<span class="pl-c1">32</span>:<span class="pl-c1">00</span>:<span class="pl-c1">0<span class="pl-ii">1</span></span>:<span class="pl-c1">00</span>
mode managed
<span class="pl-c1">CHW</span> <span class="pl-c1">None</span>
card Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span>wlan0,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">3</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># <span class="pl-k">NOTE</span>: since we are not associated, RF, CF and CHW are None</span>
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.txget(w0)
<span class="pl-c1">20</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.devstds(w0)
[<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>n<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo <span class="pl-k">=</span> pyw.phyinfo(w0) <span class="pl-c"># dict with 12 key-&gt;value pairs see info.py</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> p <span class="pl-k">in</span> pinfo: <span class="pl-c1">print</span> p, pinfo[p]
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>retry_short<span class="pl-pds">'</span></span>], pinfo[<span class="pl-s"><span class="pl-pds">'</span>retry_long<span class="pl-pds">'</span></span>]
(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>rts_thresh<span class="pl-pds">'</span></span>], pinfo[<span class="pl-s"><span class="pl-pds">'</span>frag_thresh<span class="pl-pds">'</span></span>]
(<span class="pl-c1">1024</span>, <span class="pl-c1">8000</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>cov_class<span class="pl-pds">'</span></span>]
<span class="pl-c1">0</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>generation<span class="pl-pds">'</span></span>]
<span class="pl-c1">1</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>scan_ssids<span class="pl-pds">'</span></span>]
<span class="pl-c1">20</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>ciphers<span class="pl-pds">'</span></span>]
[<span class="pl-s"><span class="pl-pds">'</span>WEP-40<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>WEP-104<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>TKIP<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>CCMP<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>modes<span class="pl-pds">'</span></span>]
[<span class="pl-s"><span class="pl-pds">'</span>ibss<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>AP<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>AP VLAN<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>swmodes<span class="pl-pds">'</span></span>]
[<span class="pl-s"><span class="pl-pds">'</span>AP VLAN<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>commands<span class="pl-pds">'</span></span>]
[<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_interface<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_interface<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_key<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>start_ap<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_station<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>new_mpath<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_mesh_config<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_bss<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>authenticate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>associate<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>deauthenticate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>disassociate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>join_ibss<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>join_mesh<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_tx_bitrate_mask<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>frame<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>frame_wait_cancel<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_wiphy_netns<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_channel<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_wds_peer<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>probe_client<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_noack_map<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>register_beacons<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>start_p2p_device<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>set_mcast_rate<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>connect<span class="pl-pds">'</span></span>,
<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">'</span>disconnect<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> d <span class="pl-k">in</span> pinfo[<span class="pl-s"><span class="pl-pds">'</span>bands<span class="pl-pds">'</span></span>]:
<span class="pl-c1">...</span>     <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">'</span>Band: <span class="pl-pds">'</span></span>, d, pinfo[<span class="pl-s"><span class="pl-pds">'</span>bands<span class="pl-pds">'</span></span>][d][<span class="pl-s"><span class="pl-pds">'</span>HT<span class="pl-pds">'</span></span>], pinfo[<span class="pl-s"><span class="pl-pds">'</span>bands<span class="pl-pds">'</span></span>][d][<span class="pl-s"><span class="pl-pds">'</span>VHT<span class="pl-pds">'</span></span>]
<span class="pl-c1">...</span>     pinfo[<span class="pl-s"><span class="pl-pds">'</span>bands<span class="pl-pds">'</span></span>][d][<span class="pl-s"><span class="pl-pds">'</span>rates<span class="pl-pds">'</span></span>]
<span class="pl-c1">...</span>     pinfo[<span class="pl-s"><span class="pl-pds">'</span>bands<span class="pl-pds">'</span></span>][d][<span class="pl-s"><span class="pl-pds">'</span>rfs<span class="pl-pds">'</span></span>]
<span class="pl-c1">...</span> 
Band:  <span class="pl-ii">5GHz</span> <span class="pl-c1">True</span> <span class="pl-c1">False</span>
[<span class="pl-c1">6.0</span>, <span class="pl-c1">9.0</span>, <span class="pl-c1">12.0</span>, <span class="pl-c1">18.0</span>, <span class="pl-c1">24.0</span>, <span class="pl-c1">36.0</span>, <span class="pl-c1">48.0</span>, <span class="pl-c1">54.0</span>]
[<span class="pl-c1">5180</span>, <span class="pl-c1">5200</span>, <span class="pl-c1">5220</span>, <span class="pl-c1">5240</span>, <span class="pl-c1">5260</span>, <span class="pl-c1">5280</span>, <span class="pl-c1">5300</span>, <span class="pl-c1">5320</span>, <span class="pl-c1">5500</span>, <span class="pl-c1">5520</span>, <span class="pl-c1">5540</span>, <span class="pl-c1">5560</span>, 
<span class="pl-c1">5580</span>, <span class="pl-c1">5600</span>, <span class="pl-c1">5620</span>, <span class="pl-c1">5640</span>, <span class="pl-c1">5660</span>, <span class="pl-c1">5680</span>, <span class="pl-c1">5700</span>, <span class="pl-c1">5745</span>, <span class="pl-c1">5765</span>, <span class="pl-c1">5785</span>, <span class="pl-c1">5805</span>, <span class="pl-c1">5825</span>]
Band:  <span class="pl-ii">2GHz</span> <span class="pl-c1">HT</span> <span class="pl-c1">True</span> <span class="pl-c1">False</span>
[<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">5.5</span>, <span class="pl-c1">11.0</span>, <span class="pl-c1">6.0</span>, <span class="pl-c1">9.0</span>, <span class="pl-c1">12.0</span>, <span class="pl-c1">18.0</span>, <span class="pl-c1">24.0</span>, <span class="pl-c1">36.0</span>, <span class="pl-c1">48.0</span>, <span class="pl-c1">54.0</span>]
[<span class="pl-c1">2412</span>, <span class="pl-c1">2417</span>, <span class="pl-c1">2422</span>, <span class="pl-c1">2427</span>, <span class="pl-c1">2432</span>, <span class="pl-c1">2437</span>, <span class="pl-c1">2442</span>, <span class="pl-c1">2447</span>, <span class="pl-c1">2452</span>, <span class="pl-c1">2457</span>, <span class="pl-c1">2462</span>, <span class="pl-c1">2467</span>, 
<span class="pl-c1">2472</span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<h4>
<a id="v-virtual-interfaces" class="anchor" href="#v-virtual-interfaces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>v. Virtual Interfaces</h4>

<p>In my experience, virtual interfaces are primarily used to recon, attack or some
other tomfoolery but can also be used to analyze your wireless network. In either
case, it is generally advised to create a virtual monitor interface and delete
all others (on the same phy) - this makes sure that some external process like
NetworkManager does not interfere with your shenanigans. In the below example,
in addition to creating an interface in monitor mode, we find all interfaces
on the same physical index and delete them. You may not need to do this.</p>

<p>NOTE: When creating a device in monitor mode, you can also set flags (see
NL80211_MNTR_FLAGS in nl80211_h), although some cards (usually atheros) do not
always obey these flag requests.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span> <span class="pl-k">in</span> pyw.devmodes(w0) <span class="pl-c"># make sure we can set wlan0 to monitor</span>
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> m0 <span class="pl-k">=</span> pyw.devadd(w0,<span class="pl-s"><span class="pl-pds">'</span>mon0<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>) <span class="pl-c"># create mon0 in monitor mode</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> m0
Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span>mon0,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">4</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.winterfaces()
[<span class="pl-s"><span class="pl-pds">'</span>mon0<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> iface <span class="pl-k">in</span> pyw.ifaces(w0):       <span class="pl-c"># delete all interfaces</span>
<span class="pl-c1">...</span>     <span class="pl-c1">print</span> iface
<span class="pl-c1">...</span>     <span class="pl-k">if</span> <span class="pl-k">not</span> iface[<span class="pl-c1">0</span>].dev <span class="pl-k">==</span> m0.dev: <span class="pl-c"># that are not our monitor</span>
<span class="pl-c1">...</span>         pyw.devdel(iface[<span class="pl-c1">0</span>])       <span class="pl-c"># on the this phy</span>
<span class="pl-c1">...</span>
(Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span>mon0,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">4</span>), <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>)
(Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span>wlan0,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">3</span>), <span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.txget(w0)
<span class="pl-c1">15</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.txset(w0,<span class="pl-c1">30</span>,<span class="pl-s"><span class="pl-pds">'</span>fixed<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># <span class="pl-k">NOTE</span>: my card does not support setting the tx power.</span>
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.up(m0) <span class="pl-c"># bring the new card up to use</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.chset(m0,<span class="pl-c1">6</span>,<span class="pl-c1">None</span>) <span class="pl-c"># and set the card to channel 6</span>
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<p>NOTE: If you don't want to add a virtual interface, you can set the mode of a current
one with modeset.</p>

<p>Once you are done, you will probably want to delete the virtual interface and
restore your original one.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> w0 <span class="pl-k">=</span> pyw.devadd(m0,<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>) <span class="pl-c"># restore wlan0 in managed mode</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.devdel(m0) <span class="pl-c"># delete the monitor interface</span>
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.up(w0) <span class="pl-c"># and bring the card up</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<p>So, perhaps you do not care for the previous method of creating a card
in monitor mode and deleting all associated interfaces and would prefer 
to execute an airmon-ng(ish) method. </p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> w0
Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> w1 <span class="pl-k">=</span> pyw.devset(w0, <span class="pl-s"><span class="pl-pds">'</span>wlan1<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> w1
Card(<span class="pl-v">phy</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-v">dev</span><span class="pl-k">=</span>wlan1,<span class="pl-v">ifindex</span><span class="pl-k">=</span><span class="pl-c1">3</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.modeset(w1, <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.up(w1)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.chset(w1, <span class="pl-c1">1</span>, <span class="pl-c1">None</span>)</pre></div>

<p>The above commands replicate the behaviour of airmon-ng. To verify, open a 
command prompt and execute the following:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">?</span><span class="pl-k">&gt;</span> iw dev wlan0 info <span class="pl-c"># replace wlan0 with your nic</span>
Interface wlan0
    ifindex 3
    wdev 0x1
    addr a0:88:b4:9e:68:58
    <span class="pl-c1">type</span> managed
    wiphy 0
<span class="pl-k">?</span><span class="pl-k">&gt;</span> sudo airmon-ng start wlan0
Found 2 processes ...
<span class="pl-k">?</span><span class="pl-k">&gt;</span> 
<span class="pl-k">?</span><span class="pl-k">&gt;</span> iw dev wlan0mon info 
Interface wlan0mon
    ifindex 6
    wdev 0x2
    addr a0:88:b4:9e:68:58
    <span class="pl-c1">type</span> monitor
    wiphy 0
    channel 10 (2457 MHz), width: 20 MHz (no HT), center1: 2457 MHz
<span class="pl-k">?</span><span class="pl-k">&gt;</span>
<span class="pl-k">?</span><span class="pl-k">&gt;</span> sudo airmon-ng stop wlan0mon
...
<span class="pl-k">?</span><span class="pl-k">&gt;</span> iw dev wlan0 info
Interface wlan0
    ifindex 7
    wdev 0x3
    addr a0:88:b4:9e:68:59
    <span class="pl-c1">type</span> managed
    wiphy 0</pre></div>

<p>As you can see, under the covers, airmon-ng deletes the specified nic 
(wlan0 in this example), creates a new one, sets the mode to monitor and
sets the channel (10 in this case). While the physical index remains the 
same, wiphy 0, the ifindex and wdev change. So, what looks like a simple
renaming of your nic and setting the mode to monitor is in face multiple
steps requiring several communications with the kernel. As stated previously,
I prefer the first method of setting a card to monitor because by 
deleting all associated interfaces, there is a smaller risk of some other
process interfering with you.</p>

<p>If you wanted, you could easily write your own python function to replicate
airmon-ng programmatically. as done below</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pyric
<span class="pl-k">import</span> pyric.pyw <span class="pl-k">as</span> pyw
<span class="pl-k">import</span> pyric.lib.libnl <span class="pl-k">as</span> nl

<span class="pl-k">def</span> <span class="pl-en">pymon</span>(<span class="pl-smi">card</span>, <span class="pl-smi">start</span><span class="pl-k">=</span><span class="pl-c1">True</span>, <span class="pl-smi">ch</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">     sets the Card card monitor mode or returns it to managed mode</span>
<span class="pl-s">     :param card: a Card object</span>
<span class="pl-s">     :param start: True = set|False = reset</span>
<span class="pl-s">     :param ch: initial ch to start on</span>
<span class="pl-s">     :returns: the new card</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    newcard <span class="pl-k">=</span> <span class="pl-c1">None</span>
    <span class="pl-k">if</span> start:
        <span class="pl-k">if</span> pyw.modeget(card) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>:
            <span class="pl-k">raise</span> <span class="pl-c1">RuntimeError</span>(<span class="pl-s"><span class="pl-pds">"</span>Card is already in monitor mode<span class="pl-pds">"</span></span>)
        newcard <span class="pl-k">=</span> pyw.devset(card, card.dev <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>mon<span class="pl-pds">'</span></span>)
        pyw.modeset(newcard, <span class="pl-s"><span class="pl-pds">'</span>monitor<span class="pl-pds">'</span></span>)
        <span class="pl-k">if</span> ch: pyw.chset(w1, ch, <span class="pl-c1">None</span>)        
        pyw.up(newcard)
    <span class="pl-k">else</span>:
        <span class="pl-k">if</span> pyw.modeget(card) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>:
            <span class="pl-k">raise</span> <span class="pl-c1">RuntimeError</span>(<span class="pl-s"><span class="pl-pds">"</span>Card is not in monitor mode<span class="pl-pds">"</span></span>)
        newcard <span class="pl-k">=</span> pyw.devset(card, card.dev[:<span class="pl-k">-</span><span class="pl-c1">3</span>)
        pyw.modeset(newcard, <span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>)        
        pyw.up(newcard)
    <span class="pl-k">return</span> newcard</pre></div>

<p>NOTE: After a recent kernel upgrade (see my post at 
<a href="https://wraithwireless.wordpress.com/2016/07/24/linux-kernel-bug/">https://wraithwireless.wordpress.com/2016/07/24/linux-kernel-bug/</a> for more details) 
devadd became unusable. I have currently put a workaround in place and there are 
now two methods to create a new card: phyadd and devadd. The function phyadd uses the 
physical number of card and does not work as expected. In short, it will create a new 
radio but not with the specified name. The function devadd uses the ifindex and works 
as expected. For those individuals who system's start without devices the following 
will work.</p>

<div class="highlight highlight-source-python"><pre>phys <span class="pl-k">=</span> pyw.phylist()
cards <span class="pl-k">=</span> []
<span class="pl-k">for</span> i, phy <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(phys):
    dcard <span class="pl-k">=</span> pyw.phyadd(phy, <span class="pl-s"><span class="pl-pds">"</span>wlan<span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(i),<span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>)
    card <span class="pl-k">=</span> pyw.devadd(card,<span class="pl-s"><span class="pl-pds">"</span>wlan<span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(i),<span class="pl-s"><span class="pl-pds">'</span>managed<span class="pl-pds">'</span></span>)
    pyw.devdel(dcard)
    cards.append(card)</pre></div>

<p>What this does is create a new card, dcard, for each phy using the phy as an 
identifier. Then, because dcard does not have the name wlan<i> but a system
generated one, we use it to create a new one, card with devadd which will have the
correct dev name. We finish up by deleting dcard and appending card to our list
of cards. </i></p>

<h4>
<a id="vi-sta-related-functions" class="anchor" href="#vi-sta-related-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>vi. STA Related Functions</h4>

<p>I have recently begun adding STA functionality to PyRIC. These are not necessarily 
required for a pentester, although the ability to disconnect a Card may come in 
handy. The difficulty is that iw only provides connect functionality through Open
or WEP enabled APs which means that I am attempting to determine which commands 
and attributes are required. If all else fails I will look to wpa_supplicant for 
more information. Additionally, iw will not connect if wpa_supplicant is running.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isconnected(w0)
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.disconnect(w0)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> pyw.isconnected(w0)
<span class="pl-c1">False</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<p>From a pentester's point of view iw link provides information of limited
quality/concern but can be useful at times. As such, link has now been
implemented. </p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> link<span class="pl-k">=</span>pyw.link(w0)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> d <span class="pl-k">in</span> link:
<span class="pl-c1">...</span>     <span class="pl-c1">print</span> d, link[d]
<span class="pl-c1">...</span> 
stat associated
ssid <span class="pl-k">****</span>net
bssid <span class="pl-c1">XX</span>:<span class="pl-c1">YY</span>:<span class="pl-c1">ZZ</span>:<span class="pl-c1">00</span>:<span class="pl-c1">11</span>:<span class="pl-c1">22</span>
chw <span class="pl-c1">20</span>
<span class="pl-c1">int</span> <span class="pl-c1">100</span>
freq <span class="pl-c1">5765</span>
tx {<span class="pl-s"><span class="pl-pds">'</span>pkts<span class="pl-pds">'</span></span>: <span class="pl-c1">256</span>, <span class="pl-s"><span class="pl-pds">'</span>failed<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">'</span>bytes<span class="pl-pds">'</span></span>: <span class="pl-c1">22969</span>, <span class="pl-s"><span class="pl-pds">'</span>bitrate<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>rate<span class="pl-pds">'</span></span>: <span class="pl-c1">6.0</span>}, 
    <span class="pl-s"><span class="pl-pds">'</span>retries<span class="pl-pds">'</span></span>: <span class="pl-c1">31</span>}
rx {<span class="pl-s"><span class="pl-pds">'</span>pkts<span class="pl-pds">'</span></span>: <span class="pl-c1">29634</span>, <span class="pl-s"><span class="pl-pds">'</span>bitrate<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>width<span class="pl-pds">'</span></span>: <span class="pl-c1">40</span>, <span class="pl-s"><span class="pl-pds">'</span>rate<span class="pl-pds">'</span></span>: <span class="pl-c1">270.0</span>, 
    <span class="pl-s"><span class="pl-pds">'</span>mcs-index<span class="pl-pds">'</span></span>: <span class="pl-c1">14</span>, <span class="pl-s"><span class="pl-pds">'</span>gi<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>}, <span class="pl-s"><span class="pl-pds">'</span>bytes<span class="pl-pds">'</span></span>: <span class="pl-c1">2365454</span>}
rss <span class="pl-k">-</span><span class="pl-c1">50</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span></pre></div>

<p>NOTE: the rx gives additional key-&gt;value pairs for bitrate. Depending on
whether the Card is transmitting (or receiving) 802.11n, the bitrate may
include values for width, mcs-index and guard interval (gi). If we look
up these values in Table 20-35 of IEEE Std 802.11-2012, we see that at 
40 MHz width, an mcs-index of 14 with a short guard interval (400ns)
the rate = 270.</p>

<p>One can also use pyw.stainfo to retrieve only tx/rx metrics.</p>

<h4>
<a id="vii-miscelleaneous-utilities" class="anchor" href="#vii-miscelleaneous-utilities" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>vii. Miscelleaneous Utilities</h4>

<p>Several additional tools are located in the utils directory. Two of these are:</p>

<ul>
<li>channels.py: defines ISM and UNII band channels/frequencies and provides
functions to convert between channel and frequency and vice-versa</li>
<li>ouifetch.py: retrieves and parses oui.txt from the IEEE website and stores
the oui data in a file that can be read by hardware.py functions
The others will be demonstrated in the following</li>
</ul>

<p>hardware.py
Driver, chipset and mac address related functions can be found here:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pyric.utils.hardware <span class="pl-k">as</span> hw

ouis <span class="pl-k">=</span> hw.parseoui() <span class="pl-c"># load the oui dict</span>
<span class="pl-c1">len</span>(ouis)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">22128</span>

mac <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>a0:88:b4:9e:68:58<span class="pl-pds">'</span></span>
dev <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>

hw.oui(mac)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>a0:88:b4<span class="pl-pds">'</span></span>

hw.ulm(mac)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>9e:68:58<span class="pl-pds">'</span></span>

hw.manufacturer(ouis,mac)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Intel Corporate<span class="pl-pds">'</span></span>

hw.randhw(ouis) <span class="pl-c"># generate a random mac address</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span><span class="pl-s"><span class="pl-pds">'</span>00:03:f0:5a:a1:fc<span class="pl-pds">'</span></span>

hw.manufacturer(ouis,<span class="pl-s"><span class="pl-pds">'</span>00:03:f0:5a:a1:fc<span class="pl-pds">'</span></span>)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Redfern Broadband Networks<span class="pl-pds">'</span></span>

hw.ifcard(<span class="pl-s"><span class="pl-pds">'</span>wlan0<span class="pl-pds">'</span></span>) <span class="pl-c"># get driver &amp; chipset</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> (<span class="pl-s"><span class="pl-pds">'</span>iwlwifi<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Intel 4965/5xxx/6xxx/1xxx<span class="pl-pds">'</span></span>)</pre></div>

<p>rfkill.py
Sometimes, your card has a soft block (or hard block) on it and it is not
recognized by command line tools or pyw. Use rkill to list, turn on or turn
off soft blocks.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pyric.utils.rfkill <span class="pl-k">as</span> rfkill

rfkill.rfkill_list() <span class="pl-c"># list rfkill devices</span>
<span class="pl-k">=</span><span class="pl-k">&gt;</span> {<span class="pl-s"><span class="pl-pds">'</span>tpacpi_bluetooth_sw<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>bluetooth<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">1</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy3<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">5</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy0<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>}}

idx <span class="pl-k">=</span> rfkill.getidx(<span class="pl-c1">3</span>)
idx
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">5</span>

rfkill.getname(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> phy3

rfkill.gettype(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>

rfkill.soft_blocked(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">False</span>

rfkill.hard_blocked(idx)
<span class="pl-k">=</span><span class="pl-k">&gt;</span> <span class="pl-c1">False</span>

rfkill.rfkill_block(idx)

rfkill.list()
<span class="pl-k">=</span><span class="pl-k">&gt;</span> {<span class="pl-s"><span class="pl-pds">'</span>tpacpi_bluetooth_sw<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>bluetooth<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">1</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy3<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">5</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy0<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>}}

rfkill.rfkill_unblock(idx)

rfkill.rfkill_list()
<span class="pl-k">=</span><span class="pl-k">&gt;</span> {<span class="pl-s"><span class="pl-pds">'</span>tpacpi_bluetooth_sw<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>bluetooth<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">1</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy3<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">5</span>},
    <span class="pl-s"><span class="pl-pds">'</span>phy0<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>soft<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>hard<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>, <span class="pl-s"><span class="pl-pds">'</span>type<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>wlan<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>idx<span class="pl-pds">'</span></span>: <span class="pl-c1">0</span>}}</pre></div>

<p>Note that rfkill_list lists all 'wireless' devices: wlan, bluetooth, wimax, wwan,
gps, fm and nfc. Another important thing to note is that the rfkill index is not
the same as the interface index.</p>

<h2>
<a id="4-extending" class="anchor" href="#4-extending" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4. EXTENDING:</h2>

<p>Extending PyRIC is fun and easy too, see the user guide PyRIC.pdf.</p>

<h2>
<a id="5-architectureheirarchy" class="anchor" href="#5-architectureheirarchy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5. ARCHITECTURE/HEIRARCHY:</h2>

<p>Brief Overview of the project file structure. Directories and/or files annotated
with (-) are not included in pip installs or PyPI downloads</p>

<ul>
<li>PyRIC                   root Distribution directory

<ul>
<li>__init__.py       initialize distrubution PyRIC module</li>
<li>examples              example folder

<ul>
<li>pentest.py          create wireless pentest environment example</li>
<li>device_details.py   display device information</li>
</ul>
</li>
<li>tests (-)             test folder

<ul>
<li>pyw.unittest.py     unit test for pyw functions</li>
</ul>
</li>
<li>docs                  User Guide resources

<ul>
<li>nlsend.png (-)      image for user guide</li>
<li>nlsock.png (-)      image for user guide</li>
<li>PyRIC.tex (-)       User tex file</li>
<li>PyRIC.bib (-)       User Guide bibliography</li>
<li>PyRIC.pdf           User Guide</li>
</ul>
</li>
<li>setup.py              install file</li>
<li>setup.cfg             used by setup.py</li>
<li>MANIFEST.in           used by setup.py</li>
<li>README.md             this file</li>
<li>LICENSE               GPLv3 License</li>
<li>TODO                  todos for PyRIC</li>
<li>pyric                 package directory

<ul>
<li>__init__.py     initialize pyric module</li>
<li>pyw.py              wireless nic functionality</li>
<li>utils               utility directory</li>
<li>__init__.py    initialize utils module</li>
<li>channels.py        802.11 ISM/UNII freqs. &amp; channels</li>
<li>hardware.py        device, chipset and mac address utility functions</li>
<li>rfkill.py          rfkill functions</li>
<li>ouifetch.py        retrieve and store oui dict from IEEE</li>
<li>data               data folder for ouis</li>
<li>oui.txt           oui file fetched from IEEE</li>
<li>net                 linux header ports

<ul>
<li>__init__.py   initialize net subpackage</li>
<li>if_h.py           inet/ifreq definition</li>
<li>sockios_h.py      socket-level I/O control calls</li>
<li>genetlink_h.py    port of genetlink.h</li>
<li>netlink_h.py      port of netlink.h</li>
<li>policy.py         defines attribute datatypes</li>
<li>wireless          wireless subpackage

<ul>
<li>__init__.py initialize wireless subpackage</li>
<li>nl80211_h.py    nl80211 constants</li>
<li>nl80211_c.py    nl80211 attribute policies</li>
<li>rfkill_h.py     rfkill header file</li>
<li>ieee80211_h.py  ieee80211.h port (subset of)</li>
</ul>
</li>
</ul>
</li>
<li>lib                 library subpackages

<ul>
<li>__init__.py   initialize lib subpackage</li>
<li>libnl.py          netlink helper functions</li>
<li>libio.py          sockios helper functions</li>
</ul>
</li>
<li>nlhelp              netlinke documentation/help

<ul>
<li>nsearch.py        nl80211 search</li>
<li>commands.help     nl80211 commands help data</li>
<li>attributes.help   nl80211 attributes help data</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/wraith-wireless">wraith-wireless</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
