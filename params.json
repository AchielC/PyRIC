{
  "name": "PyRIC",
  "tagline": "Pythonic iw (and more) for the Wireless Pentester",
  "body": "# PyRIC 0.1.5: Python Radio Interface Controller\r\n## Linux wireless library for the Python Wireless Developer and Pentester\r\n![](docs/logo.png?raw=true)\r\n\r\n[![License: GPLv3](https://img.shields.io/pypi/l/PyRIC.svg)](https://github.com/wraith-wireless/PyRIC/blob/master/LICENSE)\r\n[![PyPI Version](https://img.shields.io/pypi/v/PyRIC.svg)](https://pypi.python.org/pypi/PyRIC)\r\n[![Downloads per month on PyPI](https://img.shields.io/pypi/dm/PyRIC.svg)](https://pypi.python.org/pypi/PyRIC)\r\n![Supported Python Versions](https://img.shields.io/pypi/pyversions/PyRIC.svg)\r\n![Software status](https://img.shields.io/pypi/status/PyRIC.svg)\r\n[![Documentation Status](https://readthedocs.org/projects/pyric/badge/?version=latest)](http://pyric.readthedocs.io/en/latest/?badge=latest)\r\n\r\n## 1 DESCRIPTION:\r\nPyRIC (is a Linux only) library providing wireless developers and pentesters the\r\nability to identify, enumerate and manipulate their system's wireless cards\r\nprogrammatically in Python. Pentesting applications and scripts written in Python\r\nhave increased dramatically in recent years. However, these tools still rely on\r\nLinux command lines tools to setup and prepare and restore the system for use.\r\nUntil now. Why use subprocess.Popen, regular expressions and str.find to interact\r\nwith your wireless cards? PyRIC is:\r\n\r\n1. Pythonic: no ctypes, SWIG etc. PyRIC redefines C header files as Python and\r\nuses sockets to communicate with the kernel.\r\n2. Self-sufficient: No third-party files used. PyRIC is completely self-contained.\r\n3. Fast: (relatively speaking) PyRIC is faster than using command line tools\r\nthrough subprocess.Popen\r\n4. Parseless: Get the output you want without parsing output from command line\r\ntools. Never worry about newer iw versions and having to rewrite your parsers.\r\n5. Easy: If you can use iw, you can use PyRIC.\r\n\r\nAt it's heart, PyRIC is a Python port of (a subset of) iw and by extension, a\r\nPython port of Netlink w.r.t nl80211 functionality. The original goal of PyRIC\r\nwas to provide a simple interface to the underlying nl80211 kernel support,\r\nhandling the complex operations of Netlink seamlessy while maintaining a minimum\r\nof \"code walking\" to understand, modify and extend. But, why stop there? Since\r\nit's initial inception, PyRIC has grown. PyRIC puts iw, ifconfig, rfkill,\r\nudevadm, airmon-ng and macchanger.\r\n\r\n### a. Additions to iw\r\nSeveral \"extensions\" have been added to iw:\r\n* Persistent sockets: pyw provides the caller with functions & ability to pass\r\ntheir own netlink (or ioctl socket) to pyw functions;\r\n* One-time request for the nl80211 family id: pyw stores the family id in a\r\nglobal variable\r\n* Consolidating different \"reference\" values to wireless NICs in one class\r\n(Cards are tuples t=(dev,phy #,ifindex)\r\n\r\nThese are minimal changes but they can improve the performance of any progams\r\nthat needs to access the wireless nic repeatedly as shown in the table below.\r\n\r\n| chset      | Total    | Avg    | Longest   | Shortest |\r\n|------------|----------|--------|-----------|----------|\r\n| Popen(iw)  | 588.3059 | 0.0588 | 0.0682    | 0.0021   |\r\n| one-time   | 560.3559 | 0.0560 | 0.0645    | 0.0003   |\r\n| persistent | 257.8293 | 0.0257 | 0.0354    | 0.0004   |\r\n\r\nThe table shows benchmarks for hop time on a Alfa AWUS036NH 10000 times. Note that\r\nthere is no implication that PyRIC is faster than iw. Rather, the table shows that\r\nPyRIC is faster than using Popen to execute iw. Using one-time sockets, there is\r\na difference of 28 seconds over Popen and iw with a small decrease in the average\r\nhoptime. Not a big difference. However, the performance increased dramatically when\r\npersistent netlink sockets are used with the total time and average hop time nearly\r\nhalved.\r\n\r\n### b. Current State\r\nATT, PyRIC provides the following:\r\n* enumerate interfaces and wireless interfaces\r\n* identify a cards driver, chipset and manufacturer\r\n* get/set hardware address\r\n* get/set ip4 address, netmask and or broadcast\r\n* turn card on/off\r\n* get supported standards, commands or modes\r\n* get if info\r\n* get dev info\r\n* get phy info\r\n* get link info\r\n* get STA (connected AP) info\r\n* get/set regulatory domain\r\n* get/set mode\r\n* get/set coverage class, RTS threshold, Fragmentation threshold & retry limits\r\n* add/delete interfaces\r\n* determine if a card is connected\r\n* get link info for a connected card\r\n* enumerate ISM and UNII channels\r\n* block/unblock rfkill devices\r\n\r\nIn utils, several helpers can be found that can be used to:\r\n* enumerate channels and frequencies and convert between the two\r\n* manipulate mac addresses and generate random ones\r\n* fetch and parse the IEEE oui text file\r\n* further rfkill operations to include listing all rfkill devices\r\n\r\nFor a full listing of every function offered by pyw and helpers see the user\r\nguide PyRIC.pdf.\r\n\r\nPyRIC also provides limited help functionality concerning nl80211 commands/attributes\r\nfor those who wish to add additional commands. However, it pulls directly from\r\nthe comments nl80211 header file and may be vague.\r\n\r\n### c. What is PyRIC?\r\n\r\nTo avoid confusion, PyRIC is the system as a whole, including all header files\r\nand \"libraries\" that are required to communicate with the kernel. pyw is a\r\ninterface to these libraries providing specific funtions.\r\n\r\nWhat it does - defines programmatic access to a subset of iw, ifconfig and rkill.\r\nIn short, PyRIC provides Python wireless pentesters the ability to work with\r\nwireless cards directly from Python without having to use command line tools\r\nthrough Popen.\r\n\r\n## 2. INSTALLING/USING:\r\n\r\n### a. Requirements\r\nPyRIC has only two requirements: Linux and Python. There has been very little\r\ntesting (on my side) on kernel 4.x and Python 3 but unit testing confirms\r\nfunctionality on Python 2.7 and kernel 3.13.x.\r\n\r\n### b. Install from Package Manager\r\nObviously, the easiest way to install PyRIC is through PyPI:\r\n\r\n    sudo pip install PyRIC\r\n\r\n### c. Install from Source\r\nThe PyRIC source (tarball) can be downloaded from https://pypi.python.org/pypi/PyRIC\r\nor http://wraith-wireless.github.io/PyRIC. Additionally, the source, as a zip file,\r\ncan be downloaded from https://github.com/wraith-wireless/PyRIC. Once downloaded,\r\nextract the files and from the PyRIC directory run:\r\n\r\n    sudo python setup.py install\r\n\r\n### d. Test without Installing\r\n\r\nIf you just want to test PyRIC out, download your choice from above. After extraction,\r\nmove the pyric folder (the package directory) to your location of choice and from\r\nthere start Python and import pyw. It is very important that you do not try and\r\nrun it from PyRIC which is the distribution directory. This will break the imports\r\npyw uses.\r\n\r\nYou will only be able to test PyRIC from the pyric directory but, if you want to,\r\nyou can add it to your Python path and run it from any program or any location.\r\nTo do so, assume you untared PyRIC to /home/bob/PyRIC. Create a text file named\r\npyric.pth with one line\r\n\r\n    /home/bob/PyRIC\r\n\r\nand save this file to /usr/lib/python2.7/dist-packages (or /usr/lib/python3/dist-packages\r\nif you want to try it in Python 3).\r\n\r\n### e. Stability vs Latest\r\n\r\nKeep in mind that the most stable version and easist installallation but oldest\r\nrelease is on PyPI (installed through pip). The source on http://wraith-wireless.github.io/PyRIC tends to be\r\nnewer but may have some bugs. The most recent source but hardest to install is on\r\nhttps://github.com/wraith-wireless/pyric/releases/ It is not guaranteed to be stable\r\n(as I tend to commit changes periodically while working on the code) and may in\r\nfact not run at all.\r\n\r\n## 3. USING\r\nTo use PyRIC, see the examples folder or read throuhg PyRIC.pdf. However, for\r\nthose impatient types:\r\n\r\n```python\r\nimport pyric           # pyric errors\r\nfrom pyric import pyw  # iw functionality\r\n```\r\n\r\nwill import the basic requirements and unless otherwise stated is assumed for the\r\nexamples below. It is also assumed that the system is in the US and has three\r\ndevices lo, eth0 and wlan0 (only wlan0 of course being wireless). Keep in mind\r\nthat these examples use one-time sockets.\r\n\r\nAlthough not all functions require root, we assume that the below have been\r\nexecuted with root permissions.\r\n\r\nBefore proceeding with the examples, let's talk about pyric error handling. The\r\npyric module imports the errorcodes found in the errno module as its own. The \r\npyric error subclasses EnvironmentError and all pyric errors are tuples of the \r\nform t = (error code,error message).\r\n\r\n```python\r\n>>> try:\r\n...     #some pyric code\r\n... except pyric.error as e:\r\n...     #handle the error\r\n```\r\n\r\nWork is ongoing to help clarify some of the error messages returned by default\r\nby os.strerror for example. \r\n\r\nRead the user guide, or type dir(pyw) in your console to get a full listing\r\nof all pyw functions.\r\n\r\n### a. System/Wireless Core Functionality\r\nThese functions do not work with a specific device rather with the system.\r\n\r\n```python\r\n>>> pyw.interfaces() # get all system interfaces\r\n['lo','eth0','wlan']\r\n>>> pyw.isinterface('eth0') # deterimine if eth0 is an interface\r\nTrue\r\n>>> pyw.isinterface('bob0')\r\nFalse\r\n>>> pyw.winterfaces() # get all system wireless interfaces\r\n['wlan0']\r\n>>> pyw.isinterface('eth0') # check eth0 for wireless\r\nFalse\r\n>>> pyw.iswinterface('wlan0')\r\nTrue\r\n>>> pyw.phylist() # list all current phys (Note device ASW phy1)\r\n[(1,'phy1), (0, 'phy0')]\r\n>>> pyw.regget() # get the regulatory domain\r\n'US'\r\n>>> pyw.regset('BO') # set the regulatory domain\r\nTrue\r\n>>> pyw.regget()\r\n'BO'\r\n>>>\r\n```\r\n\r\n### b. Interface Specific\r\nRecall that PyRIC utilizes a Card object - this removes the necessity of having\r\nto remember what to pass each function i.e. whether you have to pass a device name,\r\nphysical index or ifindex. Unless otherwise stated, we will be using the card\r\nw0 instantiated as:\r\n\r\n```python\r\n>>> w0 = pyw.getcard('wlan0') # get a card for wlan0\r\n>>> w0\r\nCard(phy=0,dev='wlan0',ifindex=2)\r\n```\r\n\r\nThere are other methods to get a Card object: pyw.devinfo, in addition to\r\ninformation, will return a Card object, pyw.devadd returns a card object for the\r\nnewly created virtual interface and pyw.ifaces returns a lists of Cards for every\r\ninterface sharing the same phy.\r\n\r\nBefore continuing you may find that a Card can become invalid. For example, I\r\nhave an older system where the USB tends to fall out. You can confirm that your\r\ncard is still valid:\r\n\r\n```python\r\n>>> pyw.validcard(w0)\r\nTrue\r\n>>>\r\n```\r\n\r\n#### i. Why is my Card not Working?\r\nSometimes you may need to turn your Card on, or possibly unblock it.\r\n\r\n```python\r\n>>> pyw.isup(w0)\r\nTrue\r\n>>> pyw.down(w0)\r\n>>> pyw.isup(w0)\r\nFalse\r\n>>> pyw.up(w0)\r\n>>> pyw.isblocked(w0) # returns tup;e (Soft Block, Hard Block)\r\n(True,False)\r\n>>> pyw.unblock(w0) # turn off the softblock\r\n>>> pyw.isblocked(w0)\r\n(False,False)\r\n>>>\r\n```\r\n\r\n#### ii. Working with Mac and IP Addresses\r\n\r\n```python\r\n>>> mac = pyw.macget(w0) # get the hw addr\r\n>>> mac\r\n'a0:b1:c2:d3:e4:f5'\r\n>>>\r\n>>> pyw.down(w0): # turn the card off to set the mac\r\n>>> pyw.macset(w0,'00:1F:32:00:01:00') # lets be a nintendo device\r\n>>> pyw.up(w0) # bring wlan0 back up\r\n>>> pyw.macget(w0) # see if it worked\r\n'00:1F:32:00:01:00'\r\n>>>\r\n>>> pyw.inetget(w0) # not associated, inet won't return an address\r\n(None, None, None)\r\n>>> # NOTE: to set the inet, bcast or netmask, the card does not have to be down\r\n...\r\n>>> pyw.inetset(w0,'192.168.3.23','255.255.255.192','192.168.3.63')\r\nTrue\r\n>>> pyw.inetget(w0)\r\n('192.168.3.23', '255.255.255.192', '192.168.3.255')\r\n>>>\r\n>>> # You can also use ip4set, netmaskset and broadcastset\r\n```\r\n\r\nIt is important to note that (like ifconfig), erroneous values can be set\r\nwhen setting the inet addresses: for example you can set the ip address on\r\n192.168.3.* network with a broadcast address of 10.255.255.255.\r\n\r\n#### iii. WLAN Radio Properties\r\nYou may want to set power management or other radio properties when pentesting.\r\nParticulary, if you are configuring a rogue AP.\r\n\r\n```python\r\n>>> pyw.pwrsaveget(w0)\r\nTrue\r\n>>> pyw.pwrsaveset(w0, False) # turn off powermanagement\r\n>>> pyw.pwrsaveget(w0)\r\nFalse\r\n>>> pyw.covclassset(w0, 1) # set the coverage class\r\npyric.error: [Errno 95] Operation not supported\r\n>>> # My internal intel card does not support setting the coverage class\r\n...\r\n>>> pyw.retryshortset(w0, 5)\r\n>>> pyw.retrylongset(w0, 5)\r\n>>> # We'll check these values out shortly\r\n...\r\n>>> pyw.rtsthreshset(w0, 1024)\r\n>>> pyw.fragthreshset(w0, 8000)\r\n>>>\r\n```\r\n\r\nFor a brief description of coverage class and retry limits,\r\nsee http://www.computerhope.com/unix/iwconfig.htm. For a description of the RTS\r\nand Fragmentation thresholds see http://resources.infosecinstitute.com/rts-threshold-configuration-improved-wireless-network-performance/\r\n\r\n#### iv. Getting Info On Your Card\r\n\r\n```python\r\n>>> iinfo = pyw.ifinfo(w0)\r\n>>> for i in iinfo: print i, iinfo[i]\r\n... \r\nmask 255.255.255.192\r\ndriver iwlwifi\r\nhwaddr a0:88:b4:9e:68:58\r\nchipset Intel 4965/5xxx/6xxx/1xxx\r\nbcast 192.168.3.63\r\ninet 192.168.3.7\r\nmanufacturer Intel Corporate\r\n>>>\r\n>>> dinfo = pyw.devinfo(w0)\r\n>>> for d in dinfo: print d, dinfo[d]\r\n...\r\nwdev 1\r\nRF None\r\nCF None\r\nmac 00:1F:32:00:01:00\r\nmode managed\r\nCHW None\r\ncard Card(phy=0,dev=wlan0,ifindex=3)\r\n>>> # NOTE: since we are not associated, RF, CF and CHW are None\r\n...\r\n>>> pyw.txget(w0)\r\n20\r\n>>> pyw.devstds(w0)\r\n['b', 'g', 'n']\r\n>>> pinfo = pyw.phyinfo(w0) # dict with 12 key->value pairs see info.py\r\n>>> for p in pinfo: print p, pinfo[p]\r\n...\r\n>>> pinfo['retry_short'], pinfo['retry_long']\r\n(5, 5)\r\n>>> pinfo['rts_thresh'], pinfo['frag_thresh']\r\n(1024, 8000)\r\n>>> pinfo['cov_class']\r\n0\r\n>>> pinfo['generation']\r\n1\r\n>>> pinfo['scan_ssids']\r\n20\r\n>>> pinfo['ciphers']\r\n['WEP-40', 'WEP-104', 'TKIP', 'CCMP']\r\n>>>\r\n>>> pinfo['modes']\r\n['ibss', 'managed', 'AP', 'AP VLAN', 'monitor']\r\n>>> pinfo['swmodes']\r\n['AP VLAN', 'monitor']\r\n>>>\r\n>>> pinfo['commands']\r\n[u'new_interface', u'set_interface', u'new_key', u'start_ap', u'new_station',\r\nu'new_mpath', u'set_mesh_config', u'set_bss', u'authenticate', u'associate',\r\nu'deauthenticate', u'disassociate', u'join_ibss', u'join_mesh',\r\nu'set_tx_bitrate_mask', u'frame', u'frame_wait_cancel', u'set_wiphy_netns',\r\nu'set_channel', u'set_wds_peer', u'probe_client', u'set_noack_map',\r\nu'register_beacons', u'start_p2p_device', u'set_mcast_rate', u'connect',\r\nu'disconnect']\r\n>>>\r\n>>> for d in pinfo['bands']:\r\n...     print 'Band: ', d, pinfo['bands'][d]['HT'], pinfo['bands'][d]['VHT']\r\n...     pinfo['bands'][d]['rates']\r\n...     pinfo['bands'][d]['rfs']\r\n... \r\nBand:  5GHz True False\r\n[6.0, 9.0, 12.0, 18.0, 24.0, 36.0, 48.0, 54.0]\r\n[5180, 5200, 5220, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, \r\n5580, 5600, 5620, 5640, 5660, 5680, 5700, 5745, 5765, 5785, 5805, 5825]\r\nBand:  2GHz HT True False\r\n[1.0, 2.0, 5.5, 11.0, 6.0, 9.0, 12.0, 18.0, 24.0, 36.0, 48.0, 54.0]\r\n[2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, \r\n2472]\r\n>>>\r\n```\r\n\r\n#### v. Virtual Interfaces\r\nIn my experience, virtual interfaces are primarily used to recon, attack or some\r\nother tomfoolery but can also be used to analyze your wireless network. In either\r\ncase, it is generally advised to create a virtual monitor interface and delete\r\nall others (on the same phy) - this makes sure that some external process like\r\nNetworkManager does not interfere with your shenanigans. In the below example,\r\nin addition to creating an interface in monitor mode, we find all interfaces\r\non the same physical index and delete them. You may not need to do this.\r\n\r\nNOTE: When creating a device in monitor mode, you can also set flags (see\r\nNL80211_MNTR_FLAGS in nl80211_h), although some cards (usually atheros) do not\r\nalways obey these flag requests.\r\n\r\n```python\r\n>>> 'monitor' in pyw.devmodes(w0) # make sure we can set wlan0 to monitor\r\nTrue\r\n>>>\r\n>>> m0 = pyw.devadd(w0,'mon0','monitor') # create mon0 in monitor mode\r\n>>> m0\r\nCard(phy=0,dev=mon0,ifindex=4)\r\n>>> pyw.winterfaces()\r\n['mon0', 'wlan0']\r\n>>> for iface in pyw.ifaces(w0):       # delete all interfaces\r\n...     print iface\r\n...     if not iface[0].dev == m0.dev: # that are not our monitor\r\n...         pyw.devdel(iface[0])       # on the this phy\r\n...\r\n(Card(phy=0,dev=mon0,ifindex=4), 'monitor')\r\n(Card(phy=0,dev=wlan0,ifindex=3), 'managed')\r\n>>>\r\n>>>\r\n>>> pyw.txget(w0)\r\n15\r\n>>> pyw.txset(w0,30,'fixed')\r\n>>> # NOTE: my card does not support setting the tx power.\r\n...\r\n>>> pyw.up(m0) # bring the new card up to use\r\n>>> pyw.chset(m0,6,None) # and set the card to channel 6\r\nTrue\r\n>>>\r\n```\r\n\r\nNOTE: If you don't want to add a virtual interface, you can set the mode of a current\r\none with modeset.\r\n\r\nOnce you are done, you will probably want to delete the virtual interface and\r\nrestore your original one.\r\n\r\n```python\r\n>>> w0 = pyw.devadd(m0,'wlan0','managed') # restore wlan0 in managed mode\r\n>>> pyw.devdel(m0) # delete the monitor interface\r\nTrue\r\n>>> pyw.up(w0) # and bring the card up\r\n>>>\r\n```\r\n\r\nSo, perhaps you do not care for the previous method of creating a card\r\nin monitor mode and deleting all associated interfaces and would prefer \r\nto execute an airmon-ng(ish) method. \r\n\r\n```python\r\n>>> w0\r\nCard(phy=0,dev='wlan0',ifindex=2)\r\n>>> w1 = pyw.devset(w0, 'wlan1')\r\n>>> w1\r\nCard(phy=0,dev=wlan1,ifindex=3)\r\n>>> pyw.modeset(w1, 'monitor')\r\n>>> pyw.up(w1)\r\n>>> pyw.chset(w1, 1, None)\r\n```\r\n\r\nThe above commands execute the same internal commands as does airmon-ng. \r\nTo verify, open a command prompt and execute the following:\r\n\r\n```bash\r\n?> iw dev wlan0 info # replace wlan0 with your nic\r\nInterface wlan0\r\n\tifindex 3\r\n\twdev 0x1\r\n\taddr a0:88:b4:9e:68:58\r\n\ttype managed\r\n\twiphy 0\r\n?> sudo airmon-ng start wlan0\r\nFound 2 processes ...\r\n?> \r\n?> iw dev wlan0mon info \r\nInterface wlan0mon\r\n\tifindex 6\r\n\twdev 0x2\r\n\taddr a0:88:b4:9e:68:58\r\n\ttype monitor\r\n\twiphy 0\r\n\tchannel 10 (2457 MHz), width: 20 MHz (no HT), center1: 2457 MHz\r\n?>\r\n?> sudo airmon-ng stop wlan0mon\r\n...\r\n?> iw dev wlan0 info\r\nInterface wlan0\r\n\tifindex 7\r\n\twdev 0x3\r\n\taddr a0:88:b4:9e:68:59\r\n\ttype managed\r\n\twiphy 0\r\n```\r\n\r\nAs you can see, under the covers, airmon-ng deletes the specified nic \r\n(wlan0 in this example), creates a new one, sets the mode to monitor and\r\nsets the channel (10 in this case). While the physical index remains the \r\nsame, wiphy 0, the ifindex and wdev change. So, what looks like a simple\r\nrenaming of your nic and setting the mode to monitor is in face multiple\r\nsteps requiring several communications with the kernel. As stated previously,\r\nI prefer the first method of setting a card to monitor because by \r\ndeleting all associated interfaces, there is a smaller risk of some other\r\nprocess interfering with you.\r\n\r\nIf you wanted, you could easily write your own python function to replicate\r\nairmon-ng programmatically. as done below\r\n\r\n```python\r\nimport pyric\r\nfrom pyric import pyw\r\nfrom pyric.lib import libnl as nl\r\n\r\ndef pymon(card, start=True, ch=None):\r\n    \"\"\"\r\n     sets the Card card monitor mode or returns it to managed mode\r\n     :param card: a Card object\r\n     :param start: True = set|False = reset\r\n     :param ch: initial ch to start on\r\n     :returns: the new card\r\n    \"\"\"\r\n    newcard = None\r\n    if start:\r\n        if pyw.modeget(card) == 'monitor':\r\n            raise RuntimeError(\"Card is already in monitor mode\")\r\n        newcard = pyw.devset(card, card.dev + 'mon')\r\n        pyw.modeset(newcard, 'monitor')\r\n        if ch: pyw.chset(w1, ch, None)        \r\n        pyw.up(newcard)\r\n    else:\r\n        if pyw.modeget(card) == 'managed':\r\n            raise RuntimeError(\"Card is not in monitor mode\")\r\n        newcard = pyw.devset(card, card.dev[:-3)\r\n        pyw.modeset(newcard, 'managed')        \r\n        pyw.up(newcard)\r\n    return newcard\r\n```\r\n\r\n#### vi. STA Related Functions\r\nI have recently begun adding STA functionality to PyRIC. These are not \r\nnecessarily required for a pentester, although the ability to disconnect\r\na Card may come in handy. The difficulty is that iw only provides connect\r\nfunctionality through Open or WEP enabled APs which means that I am \r\nattempting to determine which commands and attributes are required. If all\r\nelse fails I will look to wpa_supplicant for more information. ATT two\r\ntwo functions related to STA->AP exist: a) determine if the Card is connected \r\nand b) disconnect the Card\r\n\r\n```python\r\n>>> pyw.isconnected(w0)\r\nTrue\r\n>>> pyw.disconnect(w0)\r\n>>> pyw.isconnected(w0)\r\nFalse\r\n>>>\r\n```\r\n\r\nFrom a pentester's point of view iw link provides information of limited\r\nquality/concern but can be useful at times. As such, link has now been\r\nimplemented. \r\n\r\n```python\r\n>>> link=pyw.link(w0)\r\n>>> for d in link:\r\n...     print d, link[d]\r\n... \r\nstat associated\r\nssid ****net\r\nbssid XX:YY:ZZ:00:11:22\r\nchw 20\r\nint 100\r\nfreq 5765\r\ntx {'pkts': 256, 'failed': 0, 'bytes': 22969, 'bitrate': {'rate': 6.0}, \r\n    'retries': 31}\r\nrx {'pkts': 29634, 'bitrate': {'width': 40, 'rate': 270.0, \r\n    'mcs-index': 14, 'gi': 0}, 'bytes': 2365454}\r\nrss -50\r\n>>>\r\n```\r\n\r\nNOTE: the rx gives additional key->value pairs for bitrate. Depending on\r\nwhether the Card is transmitting (or receiving) 802.11n, the bitrate may\r\ninclude values for width, mcs-index and guard interval (gi). If we look\r\nup these values in Table 20-35 of IEEE Std 802.11-2012, we see that at \r\n40 MHz width, an mcs-index of 14 with a short guard interval (400ns)\r\nthe rate = 270.\r\n\r\nOne can also use pyw.stainfo to retrieve only tx/rx metrics.\r\n\r\n#### vii. Miscelleaneous Utilities\r\nSeveral additional tools are located in the utils directory. Two of these are:\r\n * channels.py: defines ISM and UNII band channels/frequencies and provides\r\n functions to convert between channel and frequency and vice-versa\r\n * ouifetch.py: retrieves and parses oui.txt from the IEEE website and stores\r\n  the oui data in a file that can be read by hardware.py functions\r\nThe others will be demonstrated in the following\r\n\r\nhardware.py\r\nDriver, chipset and mac address related functions can be found here:\r\n\r\n``` python\r\nimport pyric.utils.hardware as hw\r\n\r\nouis = hw.parseoui() # load the oui dict\r\nlen(ouis)\r\n=> 22128\r\n\r\nmac = 'a0:88:b4:9e:68:58'\r\ndev = 'wlan0'\r\n\r\nhw.oui(mac)\r\n=> 'a0:88:b4'\r\n\r\nhw.ulm(mac)\r\n=> '9e:68:58'\r\n\r\nhw.manufacturer(ouis,mac)\r\n=> 'Intel Corporate'\r\n\r\nhw.randhw(ouis) # generate a random mac address\r\n=>'00:03:f0:5a:a1:fc'\r\n\r\nhw.manufacturer(ouis,'00:03:f0:5a:a1:fc')\r\n=> 'Redfern Broadband Networks'\r\n\r\nhw.ifcard('wlan0') # get driver & chipset\r\n=> ('iwlwifi', 'Intel 4965/5xxx/6xxx/1xxx')\r\n```\r\n\r\nrfkill.py\r\nSometimes, your card has a soft block (or hard block) on it and it is not\r\nrecognized by command line tools or pyw. Use rkill to list, turn on or turn\r\noff soft blocks.\r\n\r\n``` python\r\nfrom pyric.utils import rfkill\r\n\r\nrfkill.rfkill_list() # list rfkill devices\r\n=> {'tpacpi_bluetooth_sw': {'soft': True, 'hard': False, 'type': 'bluetooth', 'idx': 1},\r\n    'phy3': {'soft': False, 'hard': False, 'type': 'wlan', 'idx': 5},\r\n    'phy0': {'soft': False, 'hard': False, 'type': 'wlan', 'idx': 0}}\r\n\r\nidx = rfkill.getidx(3)\r\nidx\r\n=> 5\r\n\r\nrfkill.getname(idx)\r\n=> phy3\r\n\r\nrfkill.gettype(idx)\r\n=> 'wlan'\r\n\r\nrfkill.soft_blocked(idx)\r\n=> False\r\n\r\nrfkill.hard_blocked(idx)\r\n=> False\r\n\r\nrfkill.rfkill_block(idx)\r\n\r\nrfkill.list()\r\n=> {'tpacpi_bluetooth_sw': {'soft': False, 'hard': True, 'type': 'bluetooth', 'idx': 1},\r\n    'phy3': {'soft': True, 'hard': True, 'type': 'wlan', 'idx': 5},\r\n    'phy0': {'soft': True, 'hard': True, 'type': 'wlan', 'idx': 0}}\r\n\r\nrfkill.rfkill_unblock(idx)\r\n\r\nrfkill.rfkill_list()\r\n=> {'tpacpi_bluetooth_sw': {'soft': True, 'hard': False, 'type': 'bluetooth', 'idx': 1},\r\n    'phy3': {'soft': False, 'hard': False, 'type': 'wlan', 'idx': 5},\r\n    'phy0': {'soft': False, 'hard': False, 'type': 'wlan', 'idx': 0}}\r\n```\r\n\r\nNote that rfkill_list lists all 'wireless' devices: wlan, bluetooth, wimax, wwan,\r\ngps, fm and nfc. Another important thing to note is that the rfkill index is not\r\nthe same as the interface index.\r\n\r\n## 4. EXTENDING:\r\n\r\nExtending PyRIC is fun and easy too, see the user guide PyRIC.pdf.\r\n\r\n## 5. ARCHITECTURE/HEIRARCHY:\r\nBrief Overview of the project file structure. Directories and/or files annotated\r\nwith (-) are not included in pip installs or PyPI downloads\r\n\r\n* PyRIC                   root Distribution directory\r\n  - \\_\\_init\\_\\_.py       initialize distrubution PyRIC module\r\n  - examples              example folder\r\n    + pentest.py          create wireless pentest environment example\r\n    + device_details.py   display device information\r\n  - tests (-)             test folder\r\n    + pyw.unittest.py     unit test for pyw functions\r\n  - docs                  User Guide resources\r\n    + nlsend.png (-)      image for user guide\r\n    + nlsock.png (-)      image for user guide\r\n    + PyRIC.tex (-)       User tex file\r\n    + PyRIC.bib (-)       User Guide bibliography\r\n    + PyRIC.pdf           User Guide\r\n  - setup.py              install file\r\n  - setup.cfg             used by setup.py\r\n  - MANIFEST.in           used by setup.py\r\n  - README.md             this file\r\n  - LICENSE               GPLv3 License\r\n  - TODO                  todos for PyRIC\r\n  - pyric                 package directory\r\n    + \\_\\_init\\_\\_.py     initialize pyric module\r\n    + pyw.py              wireless nic functionality\r\n    + utils               utility directory\r\n     * \\_\\_init\\_\\_.py    initialize utils module\r\n     * channels.py        802.11 ISM/UNII freqs. & channels\r\n     * hardware.py        device, chipset and mac address utility functions\r\n     * rfkill.py          rfkill functions\r\n     * ouifetch.py        retrieve and store oui dict from IEEE\r\n     * data               data folder for ouis\r\n      - oui.txt           oui file fetched from IEEE\r\n    + net                 linux header ports\r\n      * \\_\\_init\\_\\_.py   initialize net subpackage\r\n      * if_h.py           inet/ifreq definition\r\n      * sockios_h.py      socket-level I/O control calls\r\n      * genetlink_h.py    port of genetlink.h\r\n      * netlink_h.py      port of netlink.h\r\n      * policy.py         defines attribute datatypes\r\n      * wireless          wireless subpackage\r\n        - \\_\\_init\\_\\_.py initialize wireless subpackage\r\n        - nl80211_h.py    nl80211 constants\r\n        - nl80211_c.py    nl80211 attribute policies\r\n        - rfkill_h.py     rfkill header file\r\n        - ieee80211_h.py  ieee80211.h port (subset of)\r\n    + lib                 library subpackages\r\n      * \\_\\_init\\_\\_.py   initialize lib subpackage\r\n      * libnl.py          netlink helper functions\r\n      * libio.py          sockios helper functions\r\n    + nlhelp              netlinke documentation/help\r\n      * nsearch.py        nl80211 search\r\n      * commands.help     nl80211 commands help data\r\n      * attributes.help   nl80211 attributes help data",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}