{
  "name": "PyRIC",
  "tagline": "Pythonic iw",
  "body": "# PyRIC: Python Radio Interface Controller\r\n\r\n## 1 DESCRIPTION:\r\nBLUF: Stop using subprocess.Popen, regular expressions and str.find. PyRIC\r\nis a python port of a subset of iw and python port of netlink (w.r.t nl80211\r\nfunctions). It arose out of a need in Wraith (https://github.com/wraith-wireless/wraith)\r\nfor Python nl80211/netlink and ioctl functionality in Python. Originally, Wraith\r\nused ifconfig, iwconfig and iw via subprocess.Popen and parsed the output. There\r\nare obvious shortfalls with this method, especially in terms of iw that is actively\r\nchanging (revisions break the parser) and I started looking for open source\r\nalternatives. There are several open source projects out there like pyroute, pymnl\r\n(and the python files included in the libnl source) but they generally have either\r\nnot been maintained recently or come with warnings. I desired a simple interface\r\nto the underlying nl80211 kernel support that handles the complex operations of\r\nnetlink seamlessy while maintaining a minimum of \"code walking\" to understand,\r\nmodify and add future operations. I decided to write my own because I do not need\r\ncomplete netlink functionality, only that provided by generic netlink and within\r\nthe nl80221 family. Additionally, for Wraith, I do not need a full blown port of\r\niw (and ifconfig, iwconfig) functionality to Python but only require the ability\r\nto turn a wireless nic on/off, get/set the hwaddr, get/set the channel, determine\r\nsome properties of the card and add/delete interfaces.\r\n\r\nSo, why did I do this? When I first started to explore the idea of moving away\r\nfrom iw output parsing, I looked at the source for iw, and existing Python ports.\r\nJust to figure out how to get the family id for nl80211 required reading through\r\nfive different source files with no comments. To that extent, I have attempted to\r\nkeep subclassing to a minimum, the total number of classes to a minimum, combine\r\nfiles where possible and where it makes since and keep the number of files required\r\nto be open simulateneously in order to understand the methodology and follow the\r\nprogram to a minimum. One can understand the PyRIC program flow with only two files\r\nopen at any time namely, pyw and libnl. In fact, only an understanding of pyw is\r\nrequired to add additional commands although an understanding of libnl is helpful\r\nespecially, if for example, the code is to be extended to handle multicast or\r\ncallbacks.\r\n\r\nIn addition to providing some ifconfig functionality, I have also added several\r\n\"extensions\" to iw:\r\n* Persistent sockets: PyRIC provides gives the caller with functions & ability to\r\npass their own netlink (or ioctl socket) to pyw functions;\r\n* One-time request for the nl80211 family id.\r\nWhile minimal, they will slightly improve the performance of any programs that\r\nneeds to access the wireless network interface repeatedly.\r\n\r\nATT, PyRIC accomplish my core needs but it is still a work in progress. It provides\r\nthe following:\r\n* enumerate interfaces and wireless interfaces\r\n* identify a cards chipset and driver\r\n* get/set hardware address\r\n* turn card on/off\r\n* get supported standards\r\n* get/set regulatory domain\r\n* get info on a device\r\n* add/delete interfaces\r\nBefore adding any other commands, I want to write a search program for nl80211\r\ncommands and attributes instead of having to search the header files for values\r\nand descriptions.\r\n\r\n### a. PyRIC Functionality\r\n\r\nWhat it does - defines programmatic access to a small subset of iw and ifconfig.\r\n\r\nWhat it does not do - handle multicast messages, callbacks or dumps, attributes\r\nor non nl80211 funtionality.\r\n\r\n### b. A word about porting\r\n\r\nWhen porting the C header files to python I use constants to define the C 'enum'\r\nand '#define' statements. For C structs I use the following:\r\n* a format string for packing,\r\n* a constant calculating the length of the format string, and\r\n* a function taking the attributes of the struct as arguments and returning the\r\npacked byte string\r\n\r\nFor example netlink.h defines the netlink message header as:\r\n\r\n```c\r\nstruct nlmsghdr {\r\n    __u32 nlmsg_len;\r\n    __u16 nlmsg_type;\r\n    __u16 nlmsg_flags;\r\n    __u32 nlmsg_seq;\r\n    __u32 nlmsg_pid;\r\n};\r\n```\r\n\r\nwhereas in netlink_h.py I define it thus:\r\n\r\n```python\r\nnl_nlmsghdr = \"IHHII\"\r\nNLMSGHDRLEN = struct.calcsize(nl_nlmsghdr)\r\ndef nlmsghdr(mlen,nltype,flags,seq,pid):\r\n    \"\"\" ... comments go here \"\"\"\r\n    return struct.pack(nl_nlmsghdr,NLMSGHDRLEN+mlen,nltype,flags,seq,pid)\r\n```\r\n\r\n## 2. INSTALLING:\r\n\r\nThe best way to install PyRIC is through PyPI:\r\n\r\n    sudo pip install --pre PyRIC\r\n\r\nNote the use of the '--pre' flag. Without it, pip will not install PyRIC since it\r\nis still in the developmental stage\r\n\r\nIf, however, you just want to test it out, download the latest tarball from\r\nhttps://github.com/wraith-wireless/pyric/releases/ or https://pypi.python.org/pypi/PyRIC/\r\nuntar and run from the downloaded package directory (pyric/pyric.\r\n\r\nIf you download only and try to run PyRIC outside of the local directory, you\r\nwill get errors. Just create a pyric.pth file in  /usr/lib/python2.7/dist-packages\r\nand add the path to pyric/pyric in this file and you will be able to run it from\r\nanywhere.\r\n\r\nOnce installed, see examples/pentest.py which covers most pyw functions.\r\n\r\n### a. Requirements\r\n* Python\r\n* linux (kernel v 3.13.x)\r\nPyRIC requires Python 2.7 and has not been tested on Python 3. It has been tested\r\non kernel 3.13.x but should work on kernel 4.x.x\r\n\r\n** 3. EXTENDING:\r\n\r\nExtending PyRIC is fun and easy too. ...documentation in progress...\r\n\r\n## 4. ARCHITECTURE/HEIRARCHY: Brief Overview of the project file structure\r\n\r\n* pyric                   root Distribution directory\r\n  - \\_\\_init\\_\\_.py       initialize 'outer' pyric module\r\n  - examples              example folder\r\n    + pentest.py          create wireless pentest environment example\r\n  - setup.py              install file\r\n  - setup.cfg             used by setup.py\r\n  - MANIFEST.in           used by setup.py\r\n  - README.md             this file\r\n  - LICENSE               GPLv3 License\r\n  * PyRIC.pdf             User Guide\r\n  - pyric                 package directory\r\n    + \\_\\_init\\_\\_.py     initialize pyric module\r\n    + pyw.py              wireless nic functionality\r\n    + radio.py            consolidate pyw in a class\r\n    + channels.py         802.11 ISM/UNII freqs. & channels\r\n    + device.py           device/chipset utility functions\r\n    + TODO                todos for PyRIC\r\n    + RFI                 comments and observations\r\n    + net                 linux header ports\r\n      * \\_\\_init\\_\\_.py   initialize net subpackage\r\n      * if_h.py           inet/ifreq definition\r\n      * sockios_h.py      socket-level I/O control calls\r\n      * genetlink_h.py    port of genetlink.h\r\n      * netlink_h.py      port of netlink.h\r\n      * policy.py         defines attribute datatypes\r\n      * wireless          wireless subpackage\r\n        - \\_\\_init\\_\\_.py initialize wireless subpackage\r\n        - nl80211_h.py    nl80211 constants\r\n        - nl80211_c.py    nl80211 attribute policies\r\n    + lib                 library subpackages\r\n      * \\_\\_init\\_\\_.py   initialize lib subpackage\r\n      * libnl.py          netlink helper functions\r\n      * libio.py          sockios helper functions\r\n    + docs                netlinke documentation/help\r\n      * nlhelp.py         nl80211 search\r\n      * commands.help     nl80211 commands help data\r\n      * attributes.help   nl80211 attributes help data\r\n      * res               User Guide resources\r\n        - PyRIC.tex       User Guide LaTex\r\n        - PyRIC.bib       User Guide bibliography",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}