{
  "name": "PyRIC",
  "tagline": "Pythonic iw",
  "body": "# PyRIC: Python Radio Interface Controller\r\n## Pythonic iw\r\n\r\n## 1 DESCRIPTION:\r\nBLUF: Stop using subprocess.Popen, regular expressions and str.find. PyRIC\r\nis a python port of a subset of iw and python port of netlink (w.r.t nl80211\r\nfunctions).\r\n\r\n### a. Background\r\nPyRIC arose out of a need in Wraith (https://github.com/wraith-wireless/wraith)\r\nfor Python nl80211/netlink and ioctl functionality. Originally, Wraith used\r\nifconfig, iwconfig and iw via subprocess.Popen and parsed the output. There\r\nare obvious shortfalls with this method, especially in terms of iw that is\r\nactively changing (revisions break the parser) and I started looking for an\r\nopen source alternative. There are several open source projects out there\r\nsuch as pyroute, pymnl (and the python files included in the libnl source) but\r\nthey generally have either not been maintained recently or come with warnings.\r\nI desired a simple interface to the underlying nl80211 kernel support that\r\nhandles the complex operations of netlink seamlessy while maintaining a minimum\r\nof \"code walking\" to understand, modify and extend. I decided to write my own\r\nbecause I do not need complete netlink functionality, only that provided by\r\ngeneric netlink and within the nl80221 family. Additionally, for Wraith, I do\r\nnot need a full blown port of iw et. al. functionality to Python but only\r\nrequire the ability to turn a wireless nic on/off, get/set the hwaddr, get/set\r\nthe channel, determine some properties of the card and add/delete interfaces.\r\n\r\nSo, why did I do this and why is it done \"this\" way? When I first started to\r\nexplore the idea of moving away from iw output parsing, I looked at the source\r\nfor iw, and existing Python ports. Just to figure out how to get the family id\r\nfor nl80211 required reading through five different source files with no\r\ncomments. To that extent, I have attempted to keep subclassing to a minimum,\r\nthe total number of classes to a minimum, combine files where possible and where\r\nit makes since and keep the number of files required to be open simulateneously\r\nin order to understand the methodology and follow the program to a minimum. One\r\ncan understand the PyRIC program flow with only two files open at any time namely,\r\npyw and libnl. In fact, only an understanding of pyw is required to add additional\r\ncommands although an understanding of libnl(.py) is helpful especially, if for\r\nexample, the code is to be extended to handle multicast or callbacks.\r\n\r\n### b. Additions to iw\r\nIn addition to providing some ifconfig functionality, I have also added several\r\n\"extensions\" to iw:\r\n* Persistent sockets: pyw provides the caller with functions & ability to pass\r\ntheir own netlink (or ioctl socket) to pyw functions;\r\n* One-time request for the nl80211 family id: pyw stores the family id in a\r\nglobal variable\r\n* Consolidating different \"reference\" values to wireless NICs in one class\r\n(Cards are tuples t=(dev,phy #,ifindex)\r\n\r\nThese are minimal changes but they can improve the performance of any progams\r\nthat need to access the wireless nic repeatedly.\r\n\r\n### c. Current State\r\nATT, PyRIC accomplish my core needs but it is still a work in progress. It provides\r\nthe following:\r\n* enumerate interfaces and wireless interfaces\r\n* identify a cards chipset and driver\r\n* get/set hardware address\r\n* turn card on/off\r\n* get supported standards\r\n* get supported commands\r\n* get supported modes\r\n* get dev info\r\n* get phy info (does not currently process the bands)\r\n* get/set regulatory domain\r\n* get/set mode\r\n* add/delete interfaces\r\n\r\nIt also provides limited help functionality concerning nl80211 commands/attributes\r\n(for those who wish to add additional commands). However, it pulls directly from\r\nthe nl80211 header file and may be vague.\r\n\r\n### d. What is PyRIC?\r\n\r\nWhat it does - defines programmatic access to a small subset of iw and ifconfig.\r\n\r\nWhat it does not do - handle multicast messages, callbacks or dumps or non nl80211\r\nfuntionality.\r\n\r\n## 2. INSTALLING/USING:\r\n\r\nStarting with version 0.0.6, the structure (see Section 4) has changed to facilitate\r\npackaging on PyPI. This restructing has of course led to some minor difficulties\r\nespecially when attempting to install (or even just test) outside of a pip\r\ninstallation.\r\n\r\n### a. Requirements\r\nPyRIC has only two requirements: Linux and Python. There has been very little\r\ntesting (on my side) on kernel 4.x and Python 3 but working out the small bugs\r\ncontinues on Python 2.7 and kernel 3.13.x.\r\n\r\n### b. Install from Package Manager\r\nObviously, the easiest way to install PyRIC is through PyPI:\r\n\r\n    sudo pip install --pre PyRIC\r\n\r\nNote the use of the '--pre' flag. Without it, pip will not install PyRIC since\r\nit is still in the developmental stage.\r\n\r\n### c. Install from Source\r\nThe PyRIC source (tarball) can be downloaded from https://pypi.python.org/pypi/PyRIC\r\nor http://wraith-wireless.github.io/PyRIC. Additionally, the source, as a zip file,\r\ncan be downloaded from https://github.com/wraith-wireless/PyRIC. Once downloaded,\r\nextract the files and from the PyRIC directory run:\r\n\r\n    sudo python setup.py install\r\n\r\n### d. Test without Installing\r\n\r\nIf you just want to test PyRIC out, download your choice from above. After extraction,\r\nmove the pyric folder (the package directory) to your location of choice and from\r\nthere start Python and import pyw. It is very important that you do not try and\r\nrun it from PyRIC which is the distribution directory. This will break the imports\r\npyw uses.\r\n\r\nYou will only be able to test PyRIC from the pyric directory but, if you want to,\r\nyou can add it to your Python path and run it from any program or any location.\r\nTo do so, assume you untared PyRIC to /home/bob/PyRIC. Create a text file named\r\npyric.pth with one line\r\n\r\n    /home/bob/PyRIC\r\n\r\nand save this file to /usr/lib/python2.7/dist-packages (or /usr/lib/python3/dist-packages\r\nif you want to try it in Python 3).\r\n\r\n### e. Stability vs Latest\r\n\r\nKeep in mind that the most stable version and easist installallation but oldest\r\nrelease is on PyPI (installed through pip). The source on http://wraith-wireless.github.io/PyRIC tends to be\r\nnewer but may have some bugs. The most recent source but hardest to install is on\r\nhttps://github.com/wraith-wireless/pyric/releases/ It is not guaranteed to be stable\r\n(as I tend to commit changes periodically while working on the code) and may in\r\nfact not run at all.\r\n\r\n## 3. USING\r\nOnce installed, see examples/pentest.py which covers most pyw functions or read\r\nthrouhg PyRIC.pdf. However, for those impatient types:\r\n\r\n```python\r\nimport pyric               # pyric error and EUNDEF error code\r\nfrom pyric import device   # driver and chipset lookup\r\nfrom pyric import channels # channels, freqs, widths and conversions\r\nfrom pyric import pyw      # iw functionality\r\n```\r\n\r\nwill import the basic requirements and is assumed for the examples below. It is also assumed\r\nthat the system is in the US and has three devices lo, eth0 and wlan0 (only wlan0 of course\r\nbeing wireless). Keep in mind that these examples use one-time sockets.\r\n\r\n### a. Wireless Core Functionality\r\nThese functions do not work with a specific device rather with the system.\r\n\r\n```python\r\n\r\npyw.interfaces() # get all system interfaces\r\n=> ['lo','eth0','wlan']\r\n\r\npyw.isinterface('eth0') # deterimine if eth0 is an interface\r\n=> True\r\n\r\npyw.isinterface('bob0')\r\n=> False\r\n\r\npyw.winterfaces() # get all system wireless interfaces\r\n=> ['wlan0']\r\n\r\npyw.isinterface('eth0') # check eth0 for wireless\r\n=> False\r\n\r\npyw.iswinterface('wlan0')\r\n=> True\r\n\r\npyw.regget() # get the regulatory domain\r\n=> 'US'\r\n\r\npyw.regset('BO') # set the regulatory domain\r\n\r\npyw.regget()\r\n=> 'BO'\r\n```\r\n\r\n### b. Interface Specific\r\nRecall that PyRIC utilizes a Card object - this removes the necessity of having  to\r\nremember what to pass each function i.e. whether it is a device name, physical index\r\nor ifindex.\r\n\r\n```python\r\nw0 = pyw.getcard('wlan0') # get a card for wlan0\r\n\r\nw0\r\n=> Card(phy=0,dev='wlan0',ifindex=2)\r\n```\r\n\r\nYou can also use pyw.devinfo to get a Card object and pyw.devadd will return a card\r\nobject for the newly created virtual interface. The card, w0, will be used throughout\r\nthe remainder of the examples.\r\n\r\n#### i. Setting The Mac Address\r\n\r\n```python\r\nmac = pyw.macget(w0) # get the hw addr\r\n\r\nmac\r\n=> 'a0:b1:c2:d3:e4:f5'\r\n\r\npyw.down(w0) # turn the card off to set the mac\r\n\r\npyw.macset(w0,'00:1F:32:00:01:00') # lets be a nintendo device\r\n\r\npyw.up(w0) # bring wlan0 back up\r\n\r\npyw.macget(w0) # see if it worked\r\n=> '00:1F:32:00:01:00'\r\n```\r\n#### ii. Getting Info On Your Card\r\n\r\n```python\r\npyw.txget(w0)\r\n=> 20\r\n\r\npyw.modeget(w0)\r\n=> 'managed'\r\n\r\npyw.devstds(w0)\r\n=> ['b', 'g', 'n']\r\n\r\npyw.devmodes(w0)\r\n=> ['ibss', 'managed', 'AP', 'AP VLAN', 'wds', 'monitor', 'mesh']\r\n\r\npyw.devcmds(w0)\r\n=> [u'new_interface', u'set_interface', u'new_key', u'start_ap', u'new_station',\r\nu'new_mpath', u'set_mesh_config', u'set_bss', u'authenticate', u'associate',\r\nu'deauthenticate', u'disassociate', u'join_ibss', u'join_mesh', u'set_tx_bitrate_mask',\r\nu'frame', u'frame_wait_cancel', u'set_wiphy_netns', u'set_channel', u'set_wds_peer',\r\nu'probe_client', u'set_noack_map', u'register_beacons', u'start_p2p_device',\r\nu'set_mcast_rate', u'connect', u'disconnect']\r\n\r\npyw.devinfo(w0)\r\n=> {'wdev': 4294967297, 'RF': None, 'CF': None, 'mac': '00:c0:ca:59:af:a6',\r\n'mode': 'managed', 'CHW': None, 'card': Card(phy=1,dev=alfa0,ifindex=4)}\r\n\r\npinfo = pyw.phyinfo(w0)\r\n\r\npinfo['scan_ssids']\r\n=> 4\r\n\r\npinfo['retry_short']\r\n=> 7\r\n\r\npinfo['retry_long']\r\n=> 4\r\n\r\npinfo['frag_thresh']\r\n=> 4294967295\r\n\r\npinfo['rts_thresh']\r\n=> 4294967295\r\n\r\npinfo['cov_class']\r\n=> 0\r\n\r\n```\r\n\r\n#### iii. Virtual Interfaces\r\nIn my experience, virtual interfaces are primarily used to recon, attack or some\r\nother tomfoolery but can also be used to analyze your wireless network. In either\r\ncase, it is generally advised to create a virtual monitor interface and delete\r\nall others (on the same phy) - this makes sure that some external process like\r\nNetworkManager does not interfere with your shenanigans. In the below example,\r\nin addition to creating an interface in monitor mode, we find all interfaces\r\non the same physical index and delete them. You may not need to do this.\r\n\r\nNOTE: When creating a device in monitor mode, you can also set flags (see\r\nNL80211_MNTR_FLAGS in nl80211_h), although some cards (usually atheros) do not\r\nalways obey these requests.\r\n\r\n```python\r\n'monitor' in pyw.devmodes(w0) # make sure we can set wlan0 to monitor\r\n=> True\r\n\r\nm0 = pyw.devadd(w0,'mon0','monitor') # create mon0 in monitor mode\r\n\r\nfor iface in pyw.ifaces(w0): # delete all interfaces\r\n    pyw.devdel(iface[0])     # on the this phy\r\n\r\npyw.up(m0) # bring the new card up to use\r\n\r\npyw.chset(m0,6,None) # and set the card to channel 6\r\n=> True\r\n\r\nm0\r\n=> Card(phy=0,dev='mon0',ifindex=3)\r\n```\r\n\r\nOf course, once you are done, you will probably want to restore your original set\r\nup.\r\n\r\n```python\r\nw0 = pyw.devadd(m0,'wlan0','managed') # restore wlan0 in managed mode\r\n\r\npyw.devdel(m0) # delete the monitor interface\r\n\r\npyw.setmac(w0,mac) # restore the original mac address\r\n\r\npyw.up(w0) # and bring the card up\r\n\r\nw0\r\n=> Card(phy0,dev='wlan0',ifindex=4)\r\n\r\n```\r\n\r\n## 4. EXTENDING:\r\n\r\nExtending PyRIC is fun and easy too, see the user guide PyRIC.pdf.\r\n\r\n## 5. ARCHITECTURE/HEIRARCHY: Brief Overview of the project file structure\r\n\r\n* PyRIC                   root Distribution directory\r\n  - \\_\\_init\\_\\_.py       initialize distrubution PyRIC module\r\n  - examples              example folder\r\n    + pentest.py          create wireless pentest environment example\r\n  - setup.py              install file\r\n  - setup.cfg             used by setup.py\r\n  - MANIFEST.in           used by setup.py\r\n  - README.md             this file\r\n  - LICENSE               GPLv3 License\r\n  - PyRIC.pdf             User Guide\r\n  - pyric                 package directory\r\n    + \\_\\_init\\_\\_.py     initialize pyric module\r\n    + pyw.py              wireless nic functionality\r\n    + radio.py            consolidate pyw in a class\r\n    + channels.py         802.11 ISM/UNII freqs. & channels\r\n    + device.py           device/chipset utility functions\r\n    + TODO                todos for PyRIC\r\n    + RFI                 comments and observations\r\n    + net                 linux header ports\r\n      * \\_\\_init\\_\\_.py   initialize net subpackage\r\n      * if_h.py           inet/ifreq definition\r\n      * sockios_h.py      socket-level I/O control calls\r\n      * genetlink_h.py    port of genetlink.h\r\n      * netlink_h.py      port of netlink.h\r\n      * policy.py         defines attribute datatypes\r\n      * wireless          wireless subpackage\r\n        - \\_\\_init\\_\\_.py initialize wireless subpackage\r\n        - nl80211_h.py    nl80211 constants\r\n        - nl80211_c.py    nl80211 attribute policies\r\n    + lib                 library subpackages\r\n      * \\_\\_init\\_\\_.py   initialize lib subpackage\r\n      * libnl.py          netlink helper functions\r\n      * libio.py          sockios helper functions\r\n    + docs                netlinke documentation/help\r\n      * nlhelp.py         nl80211 search\r\n      * commands.help     nl80211 commands help data\r\n      * attributes.help   nl80211 attributes help data\r\n      * res               User Guide resources\r\n        - PyRIC.tex       User Guide LaTex\r\n        - PyRIC.bib       User Guide bibliography\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}